<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>dretrtg的站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="dretrtg的站">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="dretrtg的站">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dretrtg的站">
  
    <link rel="alternate" href="/atom.xml" title="dretrtg的站" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.webp">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
  <script>
  let antiquityStorage = window.sessionStorage.getItem('antiquitySessionStorage');
  if (antiquityStorage == '' || antiquityStorage == null) {
    var antiquityLoader = '<div id="loaderbox"><div class="loader"><div class="load-roll"><div class="load-top"></div><div class="load-right"></div><div class="load-bottom"></div></div></div></div>';
    document.write(antiquityLoader);
    document.body.style.overflow = 'hidden'
  }
  </script>
</head>
</html>
<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-Java基础" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-02-Java基础.html">Java基础</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-02-Java基础.html" class="article-date">
  <time datetime="2019-08-02T03:52:43.000Z" itemprop="datePublished">2019-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>一、基本概念<br>1、Java程序初始化顺序<br>当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建对象。<br>-初始化三原则<br>    静态变量优先于非静态变量初始化，静态变量只初始化一次，非静态变量可能会初始化多次；<br>    父类优先于子类进行初始化；<br>    按照成员变量定义顺序进行初始化，散布在各方法中的变量定义依然在方法调用前初始化<br>-加载顺序<br>    父类（静态变量、静态语句块）<br>    子类（静态变量、静态语句块）<br>    父类（实例变量、普通语句块）<br>    父类（构造函数）<br>    子类（实例变量、普通语句块）<br>    子类（构造函数）<br>2、Java和C++区别<br>    Java是纯粹的面向对象语言，所有对象继承java.lang.Object，C++既面向对象也面向过程<br>    Java通过虚拟机实现跨平台特性，C++依赖特定平台<br>    Java没有指针<br>    Java支持自动垃圾回收，C++手动回收<br>    Java不支持多重继承，只能通过多个接口达到目的，C++支持<br>    Java不支持操作符重载<br>    Java内置线程支持，C++需要依赖第三方库<br>    Java的goto是保留字，但是不可用，c++可以使用goto<br>    Java不支持条件编译，C++通过#ifdef#ifndef等预处理命令从而实现条件编译<br>3、反射<br>    反射 (Reflection) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过 Class 获取 class 信息称之为反射（Reflection）<br>    程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>　　反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。<br>    Java 反射框架主要提供以下功能：</p>
<p>　　1. 在运行时判断任意一个对象所属的类</p>
<p>　　2. 在运行时构造任意一个类的对象</p>
<p>　　3. 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用 private 方法）</p>
<p>　　4. 在运行时调用任意一个对象的方法</p>
<p>　　重点：是运行时而不是编译时<br>4、注解<br>    注解其实就是代码中的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相对应的处理。<br>    例如：我们以前编写 Servlet 的时候，需要在 web.xml 文件配置具体的信息。我们使用了注解以后，可以直接在 Servlet 源代码上，增加注解…Servlet 就被配置到 Tomcat 上了。也就是说，注解可以给类、方法上注入信息。<br>    在SSM中注解扫描在applicationContext.xml 配置</p>
<pre><code>自定义注解类编写规则
    Annotation 型定义为 @interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口，并且不能再去继承别的类或是接口.
    参数成员只能用 public 或默认(default)这两个访问权修饰
    参数成员只能用基本类型 byte,short,char,int,long,float,double,boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组
    要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法
    注解也可以没有定义成员, 不过这样注解就没啥用了 PS：自定义注解需要使用到元注解</code></pre><p>5、泛型<br>    泛型就是操作类型的 占位符，即：假设占位符为 T，那么此次声明的数据结构操作的数据类型为T类型。</p>
<pre><code>类型通配符
    类型通配符一般是使用 ? 代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是 List&lt;String&gt;，List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt; 的父类。

    类型通配符上限通过形如 List 来定义，如此定义就是通配符泛型值接受 Number 及其下层子类类型。

    类型通配符下限通过形如 List&lt;? super Number&gt; 来定义，表示类型只能接受 Number 及其三层父类类型，如 Objec 类型的实例。</code></pre><p>6、字节与字符<br>    ASCII：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为 8 位二进制数，换算为十进制。最小值 0，最大值 255。<br>    UTF-8：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节<br>    Unicode：一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占 1 个字节的大小，中文句号“。”占 2 个字节的大小。<br>    UTF-16：一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode扩展区的一些汉字存储需要4个字节）<br>    UTF-32：世界上任何字符的存储都需要 4 个字节<br>7、访问修饰符<br>    修饰符      当前类    同 包    子 类    其他包<br>    public        √          √          √          √<br>    protected    √          √          √          ×<br>    default        √          √          ×          ×<br>    private        √          ×          ×          ×</p>
<pre><code>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。
受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。
Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。</code></pre><p>二、面向对象<br>1、Java四个基本特性<br>    抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 <br>    封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。<br>    继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。<br>    多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。</p>
<pre><code>多态的实现方式：
方法重载（overload）：实现的是编译时的多态性（也称为前绑定）。
方法重写（override）：实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西。

要实现多态需要做两件事：
    方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
    对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

项目中对多态的应用
    举一个简单的例子，在物流信息管理系统中，有两种用户：订购客户和卖房客户，两个客户都可以登录系统，他们有相同的方法 Login，但登陆之后他们会进入到不同的页面，也就是在登录的时候会有不同的操作，两种客户都继承父类的 Login 方法，但对于不同的对象，拥有不同的操作。

面相对象开发方式优点（B65）
    较高的开发效率：可以把事物进行抽象，映射为开发的对象。
    保证软件的鲁棒性：高重用性，可以重用已有的而且在相关领域经过长期测试的代码。
    保证软件的高可维护性：代码的可读性非常好，设计模式也使得代码结构清晰，拓展性好。</code></pre><p>2、重载和重写<br>    重载：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。<br>    重写：重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。根据不同的子类对象确定调用的那个方法。<br>3、面向对象开发的六个基本原则<br>    单一职责（Single Responsibility Principle 简称 SRP）：一个类应该仅有一个引起它变化的原因。在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。</p>
<pre><code>里氏替换（Liskov Substitution Principle 简称 LSP）：任何时候子类型能够替换掉它们的父类型。子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。

依赖倒置（Dependence Inversion Principle 简称 DIP）：要依赖于抽象，不要依赖于具体类。要做到依赖倒置，应该做到：①高层模块不应该依赖底层模块，二者都应该依赖于抽象；②抽象不应该依赖于具体实现，具体实现应该依赖于抽象。

接口隔离（Interface Segregation Principle 简称 ISP）：不应该强迫客户依赖于他们不用的方法 。接口要小而专，绝不能大而全。臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。

最少知识原则（Least Knowledge Principle 简称 LKP）：只和你的朋友谈话。迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。

开闭原则（Open Closed Principle 简称 OCP）：软件实体应当对扩展开放，对修改关闭。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱。


项目中用到的原则
单一职责、开放封闭、合成聚合复用(最简单的例子就是String类)、接口隔离</code></pre><p>4、内部类<br>    可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p>
<pre><code>在 Java 中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类
（一）成员内部类

public class OuterClass {
    private String str;

    public void outerDisplay(){
        System.out.println(&quot;outerClass...&quot;);
    }

    public class InnerClass{
        public void innerDisplay(){
            str = &quot;chenssy...&quot;; //使用外围内的属性
            System.out.println(str);
            outerDisplay();  //使用外围内的方法
        }
    }

    // 推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时
    public InnerClass getInnerClass(){
        return new InnerClass();
    }

    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.getInnerClass();
        inner.innerDisplay();
    }
}

在成员内部类中要注意两点：
    成员内部类中不能存在static方法, 但是可以存在static域, 前提是需要使用final关键字进行修饰.
    成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。

（二）局部内部类
有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。

（三）匿名内部类

abstract class Person {
    public abstract void eat();
}

public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}

//在接口上使用匿名内部类
interface Person {
    public void eat();
}

public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}

//Thread类的匿名内部类实现
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i &lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        t.start();
    }
}

//Runnable接口的匿名内部类实现
public class Demo {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            public void run() {
                for (int i = 1; i &lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
    }
}</code></pre><p>5、组合、继承和代理的区别<br>    定义<br>        组合：在新类中 new 另外一个类的对象，以添加该对象的特性。<br>        继承：从基类继承得到子类，获得父类的特性。<br>        代理：在代理类中创建某功能的类，调用类的一些方法以获得该类的部分特性。</p>
<pre><code>使用场合
    组合：各部件之间没什么关系，只需要组合即可。例如组装电脑，需要 new CPU(),new RAM(),new Disk()

    public class Computer {
        public Computer() {
        CPU cpu=new CPU();
        RAM ram=new RAM();
        Disk disk=new Disk();
    }
    }
    class CPU{    }
    class RAM{    }
    class Disk{    }

    继承：子类需要具有父类的功能，各子类之间有所差异。例如 Shape 类作为父类，子类有 Rectangle，CirCle，Triangle……代码不写了，大家都经常用。
    代理：飞机控制类，我不想暴露太多飞机控制的功能，只需部分前进左右转的控制（而不需要暴露发射导弹功能）。通过在代理类中 new 一个飞机控制对象，然后在方法中添加飞机控制类的各个需要暴露的功能。

    public class PlaneDelegation{    
        private PlaneControl planeControl;    //private外部不可访问

        // 飞行员权限代理类，普通飞行员不可以开火
        PlaneDelegation(){
            planeControl = new PlaneControl();
        }
        public void speed(){
            planeControl.speed();
        }
        public void left(){
            planeControl.left();
        }
        public void right(){
            planeControl.right();
        }
    }

    final class PlaneControl {// final表示不可继承，控制器都能继承那还得了
        protected void speed() {}
        protected void fire() {}
        protected void left() {}
        protected void right() {}
    }</code></pre><p>6、构造函数<br>    构造函数中不需要定义返回类型（void 是无需返回值的意思，请注意区分两者），且构造函数的名称与所在的类名完全一致，其余的与函数的特性相同，可以带有参数列表，可以存在函数的重载现象。</p>
<pre><code>构造函数作用
    创建对象。任何一个对象创建时，都需要初始化才能使用，所以任何类想要创建实例对象就必须具有构造函数。
    对象初始化。构造函数可以对对象进行初始化，并且是给与之格式（参数列表）相符合的对象初始化，是具有一定针对性的初始化函数。</code></pre><p>三、关键字<br>1、final和static的区别<br>    -final<br>        （1）数据<br>        声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。<br>        对于基本类型，final使数值不变<br>        对于引用类型，final使引用不变，也不能引用其他对象，但是被引用的对象本身是可以修改的<br>        （2）方法<br>        声明方法不能被子类覆盖，但子类可以使用<br>            private方法隐式地被指定为final，如果在子类中定义地方法和基类中地一个private方法签名相同，此时子类的方法不是覆盖基类的方法，而是在子类中定义了一个新的方法<br>        （3）类<br>        声明类不允许被继承<br>    -static<br>        （1）静态变量<br>        静态变量在内存中只存在一份，只在类初始化时赋值一次。<br>            - 静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；<br>            - 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p>
<pre><code>public class A {
    private int x;        // 实例变量
    public static int y;  // 静态变量
}

不能在成员函数内部定义static变量。

（2）静态方法
静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。
（3）静态语句块
静态语句块在类初始化时运行一次。
（4）静态内部类
内部类的一种，不依赖外部类，且不能访问外部类非静态的变量和方法。
（5）静态导包
import static com.xxx.ClassName.*
在使用静态变量和方法时不再指明ClassName，从而简化代码，但可读性降低
（6）变量赋值顺序
静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行，静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。
运行完上述内容才运行构造函数</code></pre><p>2、break\continue\return<br>    -break<br>    跳出当前循环；但是如果是嵌套循环，则只能跳出当前的这一层循环，只有逐层 break 才能跳出所有循环。<br>    -continue<br>    终止当前循环，但是不跳出循环（在循环中 continue 后面的语句是不会执行了），继续往下根据循环条件执行循环。<br>    -return<br>        return 从当前的方法中退出，返回到该调用的方法的语句处，继续执行。<br>        return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。<br>        return 后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回调用函数处。<br>        特别注意：返回值为 void 的方法，从某个判断中跳出，必须用 return。<br>3、final、finally、finalize<br>    -final（同上）<br>    -finally<br>        在异常处理的时候，提供 finally 块来执行任何的清除操作。如果抛出一个异常，那么相匹配的 catch 字句就会执行，然后控制就会进入 finally 块，前提是有 finally 块。例如：数据库连接关闭操作上</p>
<pre><code>    异常情况说明：
        在执行 try 语句块之前已经返回或抛出异常，所以 try 对应的 finally 语句并没有执行。
        我们在 try 语句块中执行了 System.exit (0) 语句，终止了 Java 虚拟机的运行。那有人说了，在一般的 Java 应用中基本上是不会调用这个 System.exit(0) 方法的
        当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行
        还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。
-finalize
     finalize() 的作用往往被认为是用来做最后的资源回收。 　　基于在自我救赎中的表现来看，此方法有很大的不确定性（不保证方法中的任务执行完）而且运行代价较高。所以用来回收资源也不会有什么好的表现。
     finalize（）没什么用
     至于为什么会存在一个鸡肋的方法：书中说 “它不是 C/C++ 中的析构函数，而是 Java 刚诞生时为了使 C/C++ 程序员更容易接受它所做出的一个妥协”。</code></pre><p>4、assert<br>    断言（assert）作为一种软件调试的方法，提供了一种在代码中进行正确性检查的机制，目前很多开发语言都支持这种机制。</p>
<p>　　在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的状态下，系统将给出警告并且退出。一般来说，assertion 用于保证程序最基本、关键的正确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常是关闭的。下面简单介绍一下 Java 中 assertion 的实现。<br>    在语法上，为了支持 assertion，Java 增加了一个关键字 assert。它包括两种表达式，分别如下：</p>
<p>　　assert &lt;boolean表达式&gt;<br>　　    如果 &lt;boolean表达式&gt; 为 true，则程序继续执行。<br>　　    如果为 false，则程序抛出 AssertionError，并终止执行。<br>　　    assert &lt;boolean表达式&gt; : &lt;错误信息表达式&gt;<br>　　    如果 &lt;boolean表达式&gt; 为 true，则程序继续执行。<br>　　    如果为 false，则程序抛出 java.lang.AssertionError，并输入&lt;错误信息表达式&gt;。<br>5、volatile<br>    volatile 是一个类型修饰符（type specifier），它是被设计用来修饰被不同线程访问和修改的变量。在使用 volatile 修饰成员变量后，所有线程在任何时间所看到变量的值都是相同的。此外，使用 volatile 会组织编译器对代码的优化，因此会降低程序的执行效率。所以，除非迫不得已，否则，能不使用 volatile 就尽量不要使用 volatile。<br>6、instanceof<br>    instanceof 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。<br>    instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。<br>四、基本数据类型与运算<br>1、Java的基本数据类型和引用类型，自动装箱和拆箱<br>    类型    存储<br>整数型<br>    byte    8<br>    short    16<br>    int    32<br>    long    64<br>浮点型<br>    float    32<br>    double    64<br>布尔型<br>    boolean    1<br>字符型<br>    char    16    </p>
<pre><code>自动装箱和拆箱
    基本数据类型和它对应的封装类型之间可以相互转换。自动拆装箱是 jdk5.0 提供的新特特性，它可以自动实现类型的转换
        装箱：从基本数据类型到封装类型叫做装箱
        拆箱：从封装类型到基本数据类型叫拆箱</code></pre><p>2、i++和++i区别<br>i++<br>    i++ 是在程序执行完毕后进行自增，而 ++i 是在程序开始执行前进行自增。<br>i++ 的操作分三步<br>    栈中取出 i<br>    i 自增 1<br>    将 i 存到栈<br>三个阶段：内存到寄存器，寄存器自增，写回内存（这三个阶段中间都可以被中断分离开）<br>所以 i++ 不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致 i 的值不正确自增</p>
<p>++i<br>在多核的机器上，CPU 在读取内存 i 时也会可能发生同时读取到同一值，这就导致两次自增，实际只增加了一次。</p>
<p>i++ 和 ++i 都不是原子操作</p>
<p>原子性：指的是一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程打断。</p>
<p>JMM 三大特性：原子性，可见性，有序性。<br>3、位运算符<br>&amp;：如果相对应位都是 1，则结果为 1，否则为 0<br>|：如果相对应位都是 0，则结果为 0，否则为 1<br>^：如果相对应位值相同，则结果为 0，否则为 1<br>~：按位取反运算符翻转操作数的每一位，即 0 变成 1，1 变成 0<br>&lt;&lt;：（左移一位乘2）按位左移运算符。左操作数按位左移右操作数指定的位数。左移 n 位表示原来的值乘 2^n</p>
<blockquote>
<blockquote>
<p>：（右移一位除2）有符号右移，按位右移运算符。左操作数按位右移右操作数指定的位数</p>
<blockquote>
<p>：无符号右移，按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充<br>4、不用额外变量交换两个整数的值</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>a = a ^ b;
b = a ^ b;
a = a ^ b;</code></pre><p>5、不使用运算符进行a+b操作<br>    a^b; 得到不含进位之和<br>    (a &amp; b)&lt;&lt;1; 进位<br>    只要进位不为零，则迭代；否则返回<br>6、&amp;和&amp;&amp; 、|和||的区别<br>    （1）&amp;&amp; 和 &amp; 都是表示与，区别是 &amp;&amp; 只要第一个条件不满足，后面条件就不再判断。而 &amp; 要对所有的条件都进行判断。<br>    （2）|| 和 | 都是表示 “或”，区别是 || 只要满足第一个条件，后面的条件就不再判断，而 | 要对所有的条件进行判断。<br>五、字符串与数组</p>
<ol>
<li><p>String,StringBuffer,StringBuilder，以及对String不变性的理解<br> String、StringBuffer、StringBuilder</p>
<pre><code>都是 final 类，都不允许被继承
String 长度是不可变的，StringBuffer、StringBuilder 长度是可变的
StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer 在 StringBuilder 的方法之上添加了 synchronized 修饰，保证线程安全
StringBuilder 比 StringBuffer 拥有更好的性能
如果一个 String 类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时 String 的速度比 StringBuffer 和 StringBuilder 的性能好的多</code></pre><p>六、异常处理</p>
</li>
<li><p>常见异常分为那两种(Exception，Error)，常见异常的基类以及常见的异常<br> Throwable 是 Java 语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。</p>
<p> 异常种类</p>
<pre><code>Error：Error 为错误，是程序无法处理的，如 OutOfMemoryError、ThreadDeath 等，出现这种情况你唯一能做的就是听之任之，交由 JVM 来处理，不过 JVM 在大多数情况下会选择终止线程。
Exception：Exception 是程序可以处理的异常。它又分为两种 CheckedException（受捡异常），一种是 UncheckedException（不受检异常）。
受检异常（CheckException）：发生在编译阶段，必须要使用 try…catch（或者throws）否则编译不通过。
非受检异常 （UncheckedException）：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序奔溃并且无法恢复。 （发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的，难以排查，我们一般都需要纵观全局才能够发现这类的异常错误，所以在程序设计中我们需要认真考虑，好好写代码，尽量处理异常，即使产生了异常，也能尽量保证程序朝着有利方向发展。 ）</code></pre><p> 常见异常的基类（Exception）</p>
<pre><code>IOException
RuntimeException</code></pre></li>
</ol>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-排序" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-排序.html">排序</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-排序.html" class="article-date">
  <time datetime="2019-08-01T07:41:26.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>1、选择排序<br>    选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<p>public static void sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length; i++) {<br>        // 寻找[i, n)区间里的最小值的索引<br>        int minIndex = i;<br>        for (int j = i + 1; j &lt; arr.length; j++) {<br>            if(arr[minIndex] &gt; arr[j]){<br>                minIndex = j;<br>            }<br>        }<br>        swap( arr , i , minIndex);<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}</p>
<p>算法分析</p>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>2、插入排序<br>插入排序从左到右进行，每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左部数组依然有序。</p>
<p>第 j 元素是通过不断向左比较并交换来实现插入过程：当第 j 元素小于第 j - 1 元素，就将它们的位置交换，然后令 j 指针向左移动一个位置，不断进行以上操作。<br>public static void sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length - 1; i++) {<br>        for (int j = i + 1; j &gt; 0; j–) {<br>            if (arr[j] &lt; arr[j - 1])<br>                swap(arr, j, j - 1); // 大量的交换会消耗时间<br>            else<br>                break;<br>        }<br>    }<br>}</p>
<p>// 改进版插入排序（减少了数组元素的操作次数）<br>public static void better_sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length; i++) {<br>        int e = arr[i];<br>        int j = i;<br>        for (; j &gt; 0; j–) {<br>            if (e &lt; arr[j - 1])<br>                arr[j] = arr[j - 1];<br>            else<br>                break;<br>        }<br>        arr[j] = e;<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}<br>算法分析</p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>3、冒泡排序<br>通过从左到右不断交换相邻逆序的相邻元素，在一轮的交换之后，可以让未排序的元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。<br>private static void sort(int[] arr) {<br>    for (int i = arr.length - 1; i &gt; 0; i–) { // 从最后一位开始确定<br>        boolean swapped = false;<br>        for (int j = 0; j &lt; i; j++) {<br>            if(arr[j] &gt; arr[j+1]){<br>                swapped = true;<br>                swap(arr,j,j+1);<br>            }<br>        }<br>        if(!swapped)<br>            return;<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}<br>4、希尔排序<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br>// 希尔排序<br>public static void sort(int[] arr) {<br>    int n = arr.length;<br>    for (int h = n / 2; h &gt; 0; h = h / 2) {<br>        // 内部是一个插入排序<br>        for (int i = 0; i &lt; n; i = i + h) {</p>
<pre><code>        int e = arr[i];
        int j = i;
        for (; j &gt; 0; j = j - h) {
            if (e &lt; arr[j - h])
                arr[j] = arr[j - h];
            else
                break;
        }
        arr[j] = e;
    }
}</code></pre><p>}</p>
<p>// 希尔排序2<br>public static void sort2(int[] arr) {<br>    int n = arr.length;<br>    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093…<br>    int h = 1;<br>    while (h &lt; n / 3) h = 3 * h + 1;</p>
<pre><code>System.out.println(h);

while (h &gt;= 1) {
    // h-sort the array
    for (int i = h; i &lt; n; i++) {

        // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序
        int e = arr[i];
        int j = i;
        for (; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)
            arr[j] = arr[j - h];
        arr[j] = e;
    }

    h /= 3;
}</code></pre><p>}<br>算法分析</p>
<p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。</p>
<p>希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。<br>5、归并排序<br>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。<br>private static void sort(int[] arr) {<br>    __MergeSort(arr, 0, arr.length - 1);<br>}</p>
<p>private static void __MergeSort(int[] arr, int l, int r) {<br>    if (l &gt;= r)<br>        return;<br>    int mid = (l + r) / 2;<br>    __MergeSort(arr, l, mid);<br>    __MergeSort(arr, mid + 1, r);<br>    merge(arr, l, mid, r);<br>}</p>
<p>// 将arr[l…mid]和arr[mid+1…r]两部分进行归并<br>private static void merge(int[] arr, int l, int mid, int r) {<br>    int[] aux = Arrays.copyOfRange(arr, l, r + 1);</p>
<pre><code>// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1
int i = l, j = mid + 1;
for (int k = l; k &lt;= r; k++) {
    if (i &gt; mid) {  // 如果左半部分元素已经全部处理完毕
        arr[k] = aux[j - l];
        j++;
    } else if (j &gt; r) {   // 如果右半部分元素已经全部处理完毕
        arr[k] = aux[i - l];
        i++;
    } else if (aux[i - l] &lt; aux[j - l]) {  // 左半部分所指元素 &lt; 右半部分所指元素
        arr[k] = aux[i - l];
        i++;
    } else {  // 左半部分所指元素 &gt;= 右半部分所指元素
        arr[k] = aux[j - l];
        j++;
    }
}</code></pre><p>}</p>
<p>private static void sort(int[] arr) {<br>    int N = arr.length;<br>    int[] aux = new int[N];<br>    for (int sz = 1; sz &lt; N; sz += sz)<br>        for (int i = 0; i + sz &lt; N; i += sz + sz)<br>            merge(arr, i, i + sz - 1, Math.min(i + sz + sz - 1, N - 1));<br>}<br>6、快速排序<br>（1）普通快速排序<br>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>public static void QuickSort(int[] arr,int l,int r){<br>    if(l&gt;=r)<br>        return;<br>    int p = partition(arr,l,r);<br>    QuickSort(arr,l,p-1);<br>    QuickSort(arr,p+1,r);<br>}</p>
<p>// 将数组通过p分割成两部分<br>// 对arr[l…r]部分进行partition操作<br>// 返回p, 使得arr[l…p-1] &lt; arr[p] ; arr[p+1…r] &gt; arr[p]<br>public static int partition(int[] arr, int l, int r) {<br>    swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);  // 加入这一行变成随机快速排序</p>
<pre><code>int v = arr[l];
int j = l;
for(int i = j +1;i&lt;=r;i++){
    if(arr[i] &lt; v){
        j++;
        swap(arr,i,j);
    }
}
swap(arr,l,j);
return j;</code></pre><p>}</p>
<p>public static void swap(int[] arr,int i,int j) {<br>    int temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>}<br>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p>
<p>快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。<br>（2）双路快速排序<br>// 双路快速排序的partition<br>// 返回p, 使得arr[l…p-1] &lt; arr[p] ; arr[p+1…r] &gt; arr[p]<br>private static int partition(int[] arr, int l, int r) {</p>
<pre><code>// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
// swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);

int v = arr[l];

// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v
int i = l + 1, j = r;
while (true) {
    // 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0
    // 思考一下为什么?
    while (i &lt;= r &amp;&amp; arr[i] &lt; v)
        i++;

    // 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0
    // 思考一下为什么?
    while (j &gt;= l + 1 &amp;&amp; arr[j] &gt; v)
        j--;

    // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)
    // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html
    if (i &gt; j)
        break;

    swap(arr, i, j);
    i++;
    j--;
}

swap(arr, l, j);

return j;</code></pre><p>}</p>
<p>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>private static void QuickSort2Ways(int[] arr, int l, int r) {<br>    // 对于小规模数组, 使用插入排序<br>    if (l &gt;= r) return;<br>    int p = partition(arr, l, r);<br>    QuickSort2Ways(arr, l, p - 1);<br>    QuickSort2Ways(arr, p + 1, r);<br>}<br>（3）三路快速排序<br>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>private static void QuickSort3Ways(int[] arr, int l, int r){</p>
<pre><code>// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
swap( arr, l, (int)(Math.random()*(r-l+1)) + l );

int v = arr[l];

int lt = l;     // arr[l+1...lt] &lt; v
int gt = r + 1; // arr[gt...r] &gt; v
int i = l+1;    // arr[lt+1...i) == v
while( i &lt; gt ){
    if( arr[i] &lt; v){
        swap( arr, i, lt+1);
        i ++;
        lt ++;
    }
    else if( arr[i] &gt; v ){
        swap( arr, i, gt-1);
        gt --;
    }
    else{ // arr[i] == v
        i ++;
    }
}
swap( arr, l, lt );

QuickSort3Ways(arr, l, lt-1);
QuickSort3Ways(arr, gt, r);</code></pre><p>}<br>7、堆排序<br>// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序<br>public class HeapSort {</p>
<pre><code>// 对整个arr数组使用HeapSort1排序
// HeapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序
// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)
// 整个堆排序的整体时间复杂度为O(nlogn)
public static void sort1(Comparable[] arr){

    int n = arr.length;
    MaxHeap&lt;Comparable&gt; maxHeap = new MaxHeap&lt;Comparable&gt;(n);
    for( int i = 0 ; i &lt; n ; i ++ )
        maxHeap.insert(arr[i]);

    for( int i = n-1 ; i &gt;= 0 ; i -- )
        arr[i] = maxHeap.extractMax();
}


// 只通过shiftDown操作进行排序
public static void sort2(Comparable[] arr){
    int n = arr.length;

    // 注意，此时我们的堆是从0开始索引的
    // 从(最后一个元素的索引-1)/2开始
    // 最后一个元素的索引 = n-1
    for( int i = (n-1-1)/2 ; i &gt;= 0 ; i -- )
        shiftDown2(arr, n, i);

    for( int i = n-1; i &gt; 0 ; i-- ){ // 这个的目的是让序列从小到大排序
        swap( arr, 0, i);
        shiftDown2(arr, i, 0);
    }
}

// 交换堆中索引为i和j的两个元素
private static void swap(Object[] arr, int i, int j){
    Object t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
}

// 原始的shiftDown过程
private static void shiftDown(Comparable[] arr, int n, int k){
    while( 2*k+1 &lt; n ){
        int j = 2*k+1;
        if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )
            j += 1;

        if( arr[k].compareTo(arr[j]) &gt;= 0 )break;

        swap( arr, k, j);
        k = j;
    }
}

// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,
// 该优化思想和我们之前对插入排序进行优化的思路是一致的
private static void shiftDown2(Comparable[] arr, int n, int k){

    Comparable e = arr[k];
    while( 2*k+1 &lt; n ){
        int j = 2*k+1;
        if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )
            j += 1;

        if( e.compareTo(arr[j]) &gt;= 0 )
            break;

        arr[k] = arr[j];
        k = j;
    }

    arr[k] = e;
}

// 测试 HeapSort
public static void main(String[] args) {
    Integer[] arr = {10, 91, 8, 7, 6, 5, 4, 3, 2, 1};
    HeapSort.sort2(arr);
    PrintHelper.printArray(arr);
}</code></pre><p>}<br>8、基数排序<br>         平均时间复杂度        原地排序    额外空间    稳定排序<br>插入排序    O(n^2)               √            O(1)        √<br>归并排序    O(nlogn)           ×            O(n)        √<br>快速排序    O(nlogn)           √            O(logn)        ×<br>堆排序        O(nlogn)           √            O(1)        ×</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-二叉树" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-二叉树.html">二叉树</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-二叉树.html" class="article-date">
  <time datetime="2019-08-01T03:16:34.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>二分查找法<br>// 非递归实现<br>private static int search(int[] data, int l, int r, int target) {<br>    int mid;<br>    while(l &lt; r) {<br>        mid = (l + r) / 2;<br>        if(data[mid] == target) {<br>            return mid;<br>        } else if(data[mid] &lt; target) {<br>            l = mid + 1;<br>        } else {<br>            r = mid;<br>        }<br>    }<br>    return -1;<br>}<br>// 递归实现<br>private static int searchDfs(int[] data, int l, int r, int target) {<br>    if(l &gt;= r) {<br>        return -1;<br>    }<br>    int mid = (l + r) / 2;<br>    if(target == data[mid]) {<br>        return mid;<br>    } else if(target &gt; data[mid]) {<br>        return searchDfs(data, mid + 1, r, target);<br>    } else {<br>        return searchDfs(data, l, mid, target);<br>    }<br>}</p>
<p>#二叉树遍历<br>/**</p>
<ul>
<li>前序遍历 非递归实现</li>
<li>Definition for a binary tree node.</li>
<li>struct TreeNode {</li>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
<li>};</li>
<li>/<br>class Solution {<br>public:<br>  vector<int> preorderTraversal(TreeNode* root) {<pre><code>vector&lt;int&gt; ans;
TreeNode* node = root;
stack&lt;TreeNode*&gt; s;
map&lt;TreeNode*, bool&gt; M;
if(node != NULL) {
    s.push(node);
    while (!s.empty()) {
        node = s.top();
        if (!M[node]) {
            ans.push_back(node-&gt;val);
            M[node] = true;
        }
        if (node-&gt;left != NULL) {
            s.push(node-&gt;left);
            node-&gt;left = NULL;
        } else if (node-&gt;right != NULL) {
            s.push(node-&gt;right);
            node-&gt;right = NULL;
        } else {
            s.pop();
        }
    }
}
return ans;</code></pre>  }<br>};</int></li>
</ul>
<p>/**</p>
<ul>
<li><p>中序遍历</p>
</li>
<li><p>Definition for a binary tree node.</p>
</li>
<li><p>struct TreeNode {</p>
</li>
<li><p>int val;</p>
</li>
<li><p>TreeNode *left;</p>
</li>
<li><p>TreeNode *right;</p>
</li>
<li><p>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</p>
</li>
<li><p>};</p>
</li>
<li><p>/<br>class Solution {<br>public:<br>  vector<int> inorderTraversal(TreeNode* root) {</int></p>
<pre><code>vector&lt;int&gt; ans;
if(root != NULL) {
    traversal(root, ans);
}
return ans;</code></pre><p>  }</p>
<p>  void traversal(TreeNode* node, vector<int> &amp;ans) {</int></p>
<pre><code>if(node-&gt;left != NULL) {
    traversal(node-&gt;left, ans);
}
ans.push_back(node-&gt;val);
if(node-&gt;right != NULL) {
    traversal(node-&gt;right, ans);
}</code></pre><p>  }<br>};</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>后序遍历</p>
</li>
<li><p>Definition for a binary tree node.</p>
</li>
<li><p>struct TreeNode {</p>
</li>
<li><p>int val;</p>
</li>
<li><p>TreeNode *left;</p>
</li>
<li><p>TreeNode *right;</p>
</li>
<li><p>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</p>
</li>
<li><p>};</p>
</li>
<li><p>/<br>class Solution {<br>public:<br>  vector<int> postorderTraversal(TreeNode* root) {</int></p>
<pre><code>vector&lt;int&gt; ans;
if(root != NULL) {
    traversal(root, ans);
}
return ans;</code></pre><p>  }</p>
<p>  void traversal(TreeNode* node, vector<int> &amp;ans) {</int></p>
<pre><code>if(node-&gt;left != NULL) {
    traversal(node-&gt;left, ans);
}
if(node-&gt;right != NULL) {
    traversal(node-&gt;right, ans);
}
ans.push_back(node-&gt;val);</code></pre><p>  }<br>};</p>
</li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-红黑树" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-红黑树.html">红黑树</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-红黑树.html" class="article-date">
  <time datetime="2019-08-01T01:01:08.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>treeMap左旋<br>//Rotate Left<br>private void rotateLeft(Entry&lt;K,V&gt; p) {<br>    if (p != null) {<br>        Entry&lt;K,V&gt; r = p.right;<br>        p.right = r.left;<br>        if (r.left != null)<br>            r.left.parent = p;<br>        r.parent = p.parent;<br>        if (p.parent == null)<br>            root = r;<br>        else if (p.parent.left == p)<br>            p.parent.left = r;<br>        else<br>            p.parent.right = r;<br>        r.left = p;<br>        p.parent = r;<br>    }<br>}</p>
<p>treeMap右旋<br>//Rotate Right<br>private void rotateRight(Entry&lt;K,V&gt; p) {<br>    if (p != null) {<br>        Entry&lt;K,V&gt; l = p.left;<br>        p.left = l.right;<br>        if (l.right != null) l.right.parent = p;<br>        l.parent = p.parent;<br>        if (p.parent == null)<br>            root = l;<br>        else if (p.parent.right == p)<br>            p.parent.right = l;<br>        else p.parent.left = l;<br>        l.right = p;<br>        p.parent = l;<br>    }<br>}</p>
<p>treeMap寻找节点后继<br>// 寻找节点后继函数successor()<br>static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {<br>    if (t == null)<br>        return null;<br>    else if (t.right != null) {// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素<br>        Entry&lt;K,V&gt; p = t.right;<br>        while (p.left != null)<br>            p = p.left;<br>        return p;<br>    } else {// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先<br>        Entry&lt;K,V&gt; p = t.parent;<br>        Entry&lt;K,V&gt; ch = t;<br>        while (p != null &amp;&amp; ch == p.right) {<br>            ch = p;<br>            p = p.parent;<br>        }<br>        return p;<br>    }<br>}</p>
<p>get()方法<br>get(Object key)方法根据指定的key值返回对应的value，该方法调用<br>了getEntry(Object key)得到相应的entry，然后返回entry.value。<br>因此getEntry()是算法的核心。算法思想是根据key的自然顺序<br>（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。<br>//getEntry()方法<br>final Entry&lt;K,V&gt; getEntry(Object key) {<br>    ……<br>    if (key == null)//不允许key值为null<br>        throw new NullPointerException();<br>    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序<br>    Entry&lt;K,V&gt; p = root;<br>    while (p != null) {<br>        int cmp = k.compareTo(p.key);<br>        if (cmp &lt; 0)//向左找<br>            p = p.left;<br>        else if (cmp &gt; 0)//向右找<br>            p = p.right;<br>        else<br>            return p;<br>    }<br>    return null;<br>}</p>
<p>put()方法<br>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，<br>看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则<br>会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改<br>变某些节点的颜色）。<br>public V put(K key, V value) {<br>    ……<br>    int cmp;<br>    Entry&lt;K,V&gt; parent;<br>    if (key == null)<br>        throw new NullPointerException();<br>    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序<br>    do {<br>        parent = t;<br>        cmp = k.compareTo(t.key);<br>        if (cmp &lt; 0) t = t.left;//向左找<br>        else if (cmp &gt; 0) t = t.right;//向右找<br>        else return t.setValue(value);<br>    } while (t != null);<br>    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry<br>    if (cmp &lt; 0) parent.left = e;<br>    else parent.right = e;<br>    fixAfterInsertion(e);//调整<br>    size++;<br>    return null;<br>}</p>
<p>//红黑树调整函数fixAfterInsertion()<br>private void fixAfterInsertion(Entry&lt;K,V&gt; x) {<br>    x.color = RED;<br>    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {<br>        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {<br>            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));<br>            if (colorOf(y) == RED) {<br>                setColor(parentOf(x), BLACK);              // 情况1<br>                setColor(y, BLACK);                        // 情况1<br>                setColor(parentOf(parentOf(x)), RED);      // 情况1<br>                x = parentOf(parentOf(x));                 // 情况1<br>            } else {<br>                if (x == rightOf(parentOf(x))) {<br>                    x = parentOf(x);                       // 情况2<br>                    rotateLeft(x);                         // 情况2<br>                }<br>                setColor(parentOf(x), BLACK);              // 情况3<br>                setColor(parentOf(parentOf(x)), RED);      // 情况3<br>                rotateRight(parentOf(parentOf(x)));        // 情况3<br>            }<br>        } else {<br>            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));<br>            if (colorOf(y) == RED) {<br>                setColor(parentOf(x), BLACK);              // 情况4<br>                setColor(y, BLACK);                        // 情况4<br>                setColor(parentOf(parentOf(x)), RED);      // 情况4<br>                x = parentOf(parentOf(x));                 // 情况4<br>            } else {<br>                if (x == leftOf(parentOf(x))) {<br>                    x = parentOf(x);                       // 情况5<br>                    rotateRight(x);                        // 情况5<br>                }<br>                setColor(parentOf(x), BLACK);              // 情况6<br>                setColor(parentOf(parentOf(x)), RED);      // 情况6<br>                rotateLeft(parentOf(parentOf(x)));         // 情况6<br>            }<br>        }<br>    }<br>    root.color = BLACK;<br>}</p>
<p>remove()函数<br>remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p>
<p>getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。</p>
<p>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p>
<p>删除点p的左右子树都为空，或者只有一棵子树非空。<br>删除点p的左右子树都非空。<br>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）。</p>
<p>基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下：<br>// 红黑树entry删除函数deleteEntry()<br>private void deleteEntry(Entry&lt;K,V&gt; p) {<br>    modCount++;<br>    size–;<br>    if (p.left != null &amp;&amp; p.right != null) {// 2. 删除点p的左右子树都非空。<br>        Entry&lt;K,V&gt; s = successor(p);// 后继<br>        p.key = s.key;<br>        p.value = s.value;<br>        p = s;<br>    }<br>    Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);<br>    if (replacement != null) {// 1. 删除点p只有一棵子树非空。<br>        replacement.parent = p.parent;<br>        if (p.parent == null)<br>            root = replacement;<br>        else if (p == p.parent.left)<br>            p.parent.left  = replacement;<br>        else<br>            p.parent.right = replacement;<br>        p.left = p.right = p.parent = null;<br>        if (p.color == BLACK)<br>            fixAfterDeletion(replacement);// 调整<br>    } else if (p.parent == null) {<br>        root = null;<br>    } else { // 1. 删除点p的左右子树都为空<br>        if (p.color == BLACK)<br>            fixAfterDeletion(p);// 调整<br>        if (p.parent != null) {<br>            if (p == p.parent.left)<br>                p.parent.left = null;<br>            else if (p == p.parent.right)<br>                p.parent.right = null;<br>            p.parent = null;<br>        }<br>    }<br>}</p>
<p>private void fixAfterDeletion(Entry&lt;K,V&gt; x) {<br>    while (x != root &amp;&amp; colorOf(x) == BLACK) {<br>        if (x == leftOf(parentOf(x))) {<br>            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));<br>            if (colorOf(sib) == RED) {<br>                setColor(sib, BLACK);                   // 情况1<br>                setColor(parentOf(x), RED);             // 情况1<br>                rotateLeft(parentOf(x));                // 情况1<br>                sib = rightOf(parentOf(x));             // 情况1<br>            }<br>            if (colorOf(leftOf(sib))  == BLACK &amp;&amp;<br>                colorOf(rightOf(sib)) == BLACK) {<br>                setColor(sib, RED);                     // 情况2<br>                x = parentOf(x);                        // 情况2<br>            } else {<br>                if (colorOf(rightOf(sib)) == BLACK) {<br>                    setColor(leftOf(sib), BLACK);       // 情况3<br>                    setColor(sib, RED);                 // 情况3<br>                    rotateRight(sib);                   // 情况3<br>                    sib = rightOf(parentOf(x));         // 情况3<br>                }<br>                setColor(sib, colorOf(parentOf(x)));    // 情况4<br>                setColor(parentOf(x), BLACK);           // 情况4<br>                setColor(rightOf(sib), BLACK);          // 情况4<br>                rotateLeft(parentOf(x));                // 情况4<br>                x = root;                               // 情况4<br>            }<br>        } else { // 跟前四种情况对称<br>            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));<br>            if (colorOf(sib) == RED) {<br>                setColor(sib, BLACK);                   // 情况5<br>                setColor(parentOf(x), RED);             // 情况5<br>                rotateRight(parentOf(x));               // 情况5<br>                sib = leftOf(parentOf(x));              // 情况5<br>            }<br>            if (colorOf(rightOf(sib)) == BLACK &amp;&amp;<br>                colorOf(leftOf(sib)) == BLACK) {<br>                setColor(sib, RED);                     // 情况6<br>                x = parentOf(x);                        // 情况6<br>            } else {<br>                if (colorOf(leftOf(sib)) == BLACK) {<br>                    setColor(rightOf(sib), BLACK);      // 情况7<br>                    setColor(sib, RED);                 // 情况7<br>                    rotateLeft(sib);                    // 情况7<br>                    sib = leftOf(parentOf(x));          // 情况7<br>                }<br>                setColor(sib, colorOf(parentOf(x)));    // 情况8<br>                setColor(parentOf(x), BLACK);           // 情况8<br>                setColor(leftOf(sib), BLACK);           // 情况8<br>                rotateRight(parentOf(x));               // 情况8<br>                x = root;                               // 情况8<br>            }<br>        }<br>    }<br>    setColor(x, BLACK);<br>}</p>
<p>TreeSet<br>// TreeSet是对TreeMap的简单包装<br>public class TreeSet<e> extends AbstractSet<e><br>    implements NavigableSet<e>, Cloneable, java.io.Serializable<br>{<br>    ……<br>    private transient NavigableMap&lt;E,Object&gt; m;<br>    // Dummy value to associate with an Object in the backing Map<br>    private static final Object PRESENT = new Object();<br>    public TreeSet() {<br>        this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap<br>    }<br>    ……<br>    public boolean add(E e) {<br>        return m.put(e, PRESENT)==null;<br>    }<br>    ……<br>}</e></e></e></p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-test" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/uncategorized/2019-07-31-test.html">test</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/uncategorized/2019-07-31-test.html" class="article-date">
  <time datetime="2019-07-31T13:37:35.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/历史/">历史</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>test</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-second-commit" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/编程/2019-07-31-second-commit.html">second-commit</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/编程/2019-07-31-second-commit.html" class="article-date">
  <time datetime="2019-07-31T07:37:10.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程/">编程</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/历史/">历史</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>这里应该是安全的</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-hello-world" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/uncategorized/2019-07-31-hello-world.html">Hello World</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/uncategorized/2019-07-31-hello-world.html" class="article-date">
  <time datetime="2019-07-31T03:20:44.619Z" itemprop="datePublished">2019-07-31</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    
  </div>
  
  
</article>

  



</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.webp" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        天佑昨日
      
    </h3>
    <p class="avatar-slogan">
      明日不可求 幸得昨日来
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/历史/" style="font-size: 15px;">历史</a> <a href="/tags/数据结构与算法/" style="font-size: 20px;">数据结构与算法</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/技术/2019-08-02-Java基础.html">Java基础</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-01-排序.html">排序</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-01-二叉树.html">二叉树</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-01-红黑树.html">红黑树</a>
          </li>
        
          <li>
            <a href="/posts/uncategorized/2019-07-31-test.html">test</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://dretrtg.github.io/" title target='_blank'
        >dretrtg</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 dretrtg &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>dretrtg的站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="dretrtg的站">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="dretrtg的站">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dretrtg的站">
  
    <link rel="alternate" href="/atom.xml" title="dretrtg的站" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.webp">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
  <script>
  let antiquityStorage = window.sessionStorage.getItem('antiquitySessionStorage');
  if (antiquityStorage == '' || antiquityStorage == null) {
    var antiquityLoader = '<div id="loaderbox"><div class="loader"><div class="load-roll"><div class="load-top"></div><div class="load-right"></div><div class="load-bottom"></div></div></div></div>';
    document.write(antiquityLoader);
    document.body.style.overflow = 'hidden'
  }
  </script>
</head>
</html>
<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-排序" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-排序.html">排序</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-排序.html" class="article-date">
  <time datetime="2019-08-01T07:41:26.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>1、选择排序<br>    选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<p>public static void sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length; i++) {<br>        // 寻找[i, n)区间里的最小值的索引<br>        int minIndex = i;<br>        for (int j = i + 1; j &lt; arr.length; j++) {<br>            if(arr[minIndex] &gt; arr[j]){<br>                minIndex = j;<br>            }<br>        }<br>        swap( arr , i , minIndex);<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}</p>
<p>算法分析</p>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>2、插入排序<br>插入排序从左到右进行，每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左部数组依然有序。</p>
<p>第 j 元素是通过不断向左比较并交换来实现插入过程：当第 j 元素小于第 j - 1 元素，就将它们的位置交换，然后令 j 指针向左移动一个位置，不断进行以上操作。<br>public static void sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length - 1; i++) {<br>        for (int j = i + 1; j &gt; 0; j–) {<br>            if (arr[j] &lt; arr[j - 1])<br>                swap(arr, j, j - 1); // 大量的交换会消耗时间<br>            else<br>                break;<br>        }<br>    }<br>}</p>
<p>// 改进版插入排序（减少了数组元素的操作次数）<br>public static void better_sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length; i++) {<br>        int e = arr[i];<br>        int j = i;<br>        for (; j &gt; 0; j–) {<br>            if (e &lt; arr[j - 1])<br>                arr[j] = arr[j - 1];<br>            else<br>                break;<br>        }<br>        arr[j] = e;<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}<br>算法分析</p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>3、冒泡排序<br>通过从左到右不断交换相邻逆序的相邻元素，在一轮的交换之后，可以让未排序的元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。<br>private static void sort(int[] arr) {<br>    for (int i = arr.length - 1; i &gt; 0; i–) { // 从最后一位开始确定<br>        boolean swapped = false;<br>        for (int j = 0; j &lt; i; j++) {<br>            if(arr[j] &gt; arr[j+1]){<br>                swapped = true;<br>                swap(arr,j,j+1);<br>            }<br>        }<br>        if(!swapped)<br>            return;<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}<br>4、希尔排序<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br>// 希尔排序<br>public static void sort(int[] arr) {<br>    int n = arr.length;<br>    for (int h = n / 2; h &gt; 0; h = h / 2) {<br>        // 内部是一个插入排序<br>        for (int i = 0; i &lt; n; i = i + h) {</p>
<pre><code>        int e = arr[i];
        int j = i;
        for (; j &gt; 0; j = j - h) {
            if (e &lt; arr[j - h])
                arr[j] = arr[j - h];
            else
                break;
        }
        arr[j] = e;
    }
}</code></pre><p>}</p>
<p>// 希尔排序2<br>public static void sort2(int[] arr) {<br>    int n = arr.length;<br>    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093…<br>    int h = 1;<br>    while (h &lt; n / 3) h = 3 * h + 1;</p>
<pre><code>System.out.println(h);

while (h &gt;= 1) {
    // h-sort the array
    for (int i = h; i &lt; n; i++) {

        // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序
        int e = arr[i];
        int j = i;
        for (; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)
            arr[j] = arr[j - h];
        arr[j] = e;
    }

    h /= 3;
}</code></pre><p>}<br>算法分析</p>
<p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。</p>
<p>希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。<br>5、归并排序<br>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。<br>private static void sort(int[] arr) {<br>    __MergeSort(arr, 0, arr.length - 1);<br>}</p>
<p>private static void __MergeSort(int[] arr, int l, int r) {<br>    if (l &gt;= r)<br>        return;<br>    int mid = (l + r) / 2;<br>    __MergeSort(arr, l, mid);<br>    __MergeSort(arr, mid + 1, r);<br>    merge(arr, l, mid, r);<br>}</p>
<p>// 将arr[l…mid]和arr[mid+1…r]两部分进行归并<br>private static void merge(int[] arr, int l, int mid, int r) {<br>    int[] aux = Arrays.copyOfRange(arr, l, r + 1);</p>
<pre><code>// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1
int i = l, j = mid + 1;
for (int k = l; k &lt;= r; k++) {
    if (i &gt; mid) {  // 如果左半部分元素已经全部处理完毕
        arr[k] = aux[j - l];
        j++;
    } else if (j &gt; r) {   // 如果右半部分元素已经全部处理完毕
        arr[k] = aux[i - l];
        i++;
    } else if (aux[i - l] &lt; aux[j - l]) {  // 左半部分所指元素 &lt; 右半部分所指元素
        arr[k] = aux[i - l];
        i++;
    } else {  // 左半部分所指元素 &gt;= 右半部分所指元素
        arr[k] = aux[j - l];
        j++;
    }
}</code></pre><p>}</p>
<p>private static void sort(int[] arr) {<br>    int N = arr.length;<br>    int[] aux = new int[N];<br>    for (int sz = 1; sz &lt; N; sz += sz)<br>        for (int i = 0; i + sz &lt; N; i += sz + sz)<br>            merge(arr, i, i + sz - 1, Math.min(i + sz + sz - 1, N - 1));<br>}<br>6、快速排序<br>（1）普通快速排序<br>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>public static void QuickSort(int[] arr,int l,int r){<br>    if(l&gt;=r)<br>        return;<br>    int p = partition(arr,l,r);<br>    QuickSort(arr,l,p-1);<br>    QuickSort(arr,p+1,r);<br>}</p>
<p>// 将数组通过p分割成两部分<br>// 对arr[l…r]部分进行partition操作<br>// 返回p, 使得arr[l…p-1] &lt; arr[p] ; arr[p+1…r] &gt; arr[p]<br>public static int partition(int[] arr, int l, int r) {<br>    swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);  // 加入这一行变成随机快速排序</p>
<pre><code>int v = arr[l];
int j = l;
for(int i = j +1;i&lt;=r;i++){
    if(arr[i] &lt; v){
        j++;
        swap(arr,i,j);
    }
}
swap(arr,l,j);
return j;</code></pre><p>}</p>
<p>public static void swap(int[] arr,int i,int j) {<br>    int temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>}<br>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p>
<p>快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。<br>（2）双路快速排序<br>// 双路快速排序的partition<br>// 返回p, 使得arr[l…p-1] &lt; arr[p] ; arr[p+1…r] &gt; arr[p]<br>private static int partition(int[] arr, int l, int r) {</p>
<pre><code>// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
// swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);

int v = arr[l];

// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v
int i = l + 1, j = r;
while (true) {
    // 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0
    // 思考一下为什么?
    while (i &lt;= r &amp;&amp; arr[i] &lt; v)
        i++;

    // 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0
    // 思考一下为什么?
    while (j &gt;= l + 1 &amp;&amp; arr[j] &gt; v)
        j--;

    // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)
    // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html
    if (i &gt; j)
        break;

    swap(arr, i, j);
    i++;
    j--;
}

swap(arr, l, j);

return j;</code></pre><p>}</p>
<p>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>private static void QuickSort2Ways(int[] arr, int l, int r) {<br>    // 对于小规模数组, 使用插入排序<br>    if (l &gt;= r) return;<br>    int p = partition(arr, l, r);<br>    QuickSort2Ways(arr, l, p - 1);<br>    QuickSort2Ways(arr, p + 1, r);<br>}<br>（3）三路快速排序<br>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>private static void QuickSort3Ways(int[] arr, int l, int r){</p>
<pre><code>// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
swap( arr, l, (int)(Math.random()*(r-l+1)) + l );

int v = arr[l];

int lt = l;     // arr[l+1...lt] &lt; v
int gt = r + 1; // arr[gt...r] &gt; v
int i = l+1;    // arr[lt+1...i) == v
while( i &lt; gt ){
    if( arr[i] &lt; v){
        swap( arr, i, lt+1);
        i ++;
        lt ++;
    }
    else if( arr[i] &gt; v ){
        swap( arr, i, gt-1);
        gt --;
    }
    else{ // arr[i] == v
        i ++;
    }
}
swap( arr, l, lt );

QuickSort3Ways(arr, l, lt-1);
QuickSort3Ways(arr, gt, r);</code></pre><p>}<br>7、堆排序<br>// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序<br>public class HeapSort {</p>
<pre><code>// 对整个arr数组使用HeapSort1排序
// HeapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序
// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)
// 整个堆排序的整体时间复杂度为O(nlogn)
public static void sort1(Comparable[] arr){

    int n = arr.length;
    MaxHeap&lt;Comparable&gt; maxHeap = new MaxHeap&lt;Comparable&gt;(n);
    for( int i = 0 ; i &lt; n ; i ++ )
        maxHeap.insert(arr[i]);

    for( int i = n-1 ; i &gt;= 0 ; i -- )
        arr[i] = maxHeap.extractMax();
}


// 只通过shiftDown操作进行排序
public static void sort2(Comparable[] arr){
    int n = arr.length;

    // 注意，此时我们的堆是从0开始索引的
    // 从(最后一个元素的索引-1)/2开始
    // 最后一个元素的索引 = n-1
    for( int i = (n-1-1)/2 ; i &gt;= 0 ; i -- )
        shiftDown2(arr, n, i);

    for( int i = n-1; i &gt; 0 ; i-- ){ // 这个的目的是让序列从小到大排序
        swap( arr, 0, i);
        shiftDown2(arr, i, 0);
    }
}

// 交换堆中索引为i和j的两个元素
private static void swap(Object[] arr, int i, int j){
    Object t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
}

// 原始的shiftDown过程
private static void shiftDown(Comparable[] arr, int n, int k){
    while( 2*k+1 &lt; n ){
        int j = 2*k+1;
        if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )
            j += 1;

        if( arr[k].compareTo(arr[j]) &gt;= 0 )break;

        swap( arr, k, j);
        k = j;
    }
}

// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,
// 该优化思想和我们之前对插入排序进行优化的思路是一致的
private static void shiftDown2(Comparable[] arr, int n, int k){

    Comparable e = arr[k];
    while( 2*k+1 &lt; n ){
        int j = 2*k+1;
        if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )
            j += 1;

        if( e.compareTo(arr[j]) &gt;= 0 )
            break;

        arr[k] = arr[j];
        k = j;
    }

    arr[k] = e;
}

// 测试 HeapSort
public static void main(String[] args) {
    Integer[] arr = {10, 91, 8, 7, 6, 5, 4, 3, 2, 1};
    HeapSort.sort2(arr);
    PrintHelper.printArray(arr);
}</code></pre><p>}<br>8、基数排序<br>         平均时间复杂度        原地排序    额外空间    稳定排序<br>插入排序    O(n^2)               √            O(1)        √<br>归并排序    O(nlogn)           ×            O(n)        √<br>快速排序    O(nlogn)           √            O(logn)        ×<br>堆排序        O(nlogn)           √            O(1)        ×</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-二叉树" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-二叉树.html">二叉树</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-二叉树.html" class="article-date">
  <time datetime="2019-08-01T03:16:34.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>二分查找法<br>// 非递归实现<br>private static int search(int[] data, int l, int r, int target) {<br>    int mid;<br>    while(l &lt; r) {<br>        mid = (l + r) / 2;<br>        if(data[mid] == target) {<br>            return mid;<br>        } else if(data[mid] &lt; target) {<br>            l = mid + 1;<br>        } else {<br>            r = mid;<br>        }<br>    }<br>    return -1;<br>}<br>// 递归实现<br>private static int searchDfs(int[] data, int l, int r, int target) {<br>    if(l &gt;= r) {<br>        return -1;<br>    }<br>    int mid = (l + r) / 2;<br>    if(target == data[mid]) {<br>        return mid;<br>    } else if(target &gt; data[mid]) {<br>        return searchDfs(data, mid + 1, r, target);<br>    } else {<br>        return searchDfs(data, l, mid, target);<br>    }<br>}</p>
<p>#二叉树遍历<br>/**</p>
<ul>
<li>前序遍历 非递归实现</li>
<li>Definition for a binary tree node.</li>
<li>struct TreeNode {</li>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
<li>};</li>
<li>/<br>class Solution {<br>public:<br>  vector<int> preorderTraversal(TreeNode* root) {<pre><code>vector&lt;int&gt; ans;
TreeNode* node = root;
stack&lt;TreeNode*&gt; s;
map&lt;TreeNode*, bool&gt; M;
if(node != NULL) {
    s.push(node);
    while (!s.empty()) {
        node = s.top();
        if (!M[node]) {
            ans.push_back(node-&gt;val);
            M[node] = true;
        }
        if (node-&gt;left != NULL) {
            s.push(node-&gt;left);
            node-&gt;left = NULL;
        } else if (node-&gt;right != NULL) {
            s.push(node-&gt;right);
            node-&gt;right = NULL;
        } else {
            s.pop();
        }
    }
}
return ans;</code></pre>  }<br>};</int></li>
</ul>
<p>/**</p>
<ul>
<li><p>中序遍历</p>
</li>
<li><p>Definition for a binary tree node.</p>
</li>
<li><p>struct TreeNode {</p>
</li>
<li><p>int val;</p>
</li>
<li><p>TreeNode *left;</p>
</li>
<li><p>TreeNode *right;</p>
</li>
<li><p>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</p>
</li>
<li><p>};</p>
</li>
<li><p>/<br>class Solution {<br>public:<br>  vector<int> inorderTraversal(TreeNode* root) {</int></p>
<pre><code>vector&lt;int&gt; ans;
if(root != NULL) {
    traversal(root, ans);
}
return ans;</code></pre><p>  }</p>
<p>  void traversal(TreeNode* node, vector<int> &amp;ans) {</int></p>
<pre><code>if(node-&gt;left != NULL) {
    traversal(node-&gt;left, ans);
}
ans.push_back(node-&gt;val);
if(node-&gt;right != NULL) {
    traversal(node-&gt;right, ans);
}</code></pre><p>  }<br>};</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>后序遍历</p>
</li>
<li><p>Definition for a binary tree node.</p>
</li>
<li><p>struct TreeNode {</p>
</li>
<li><p>int val;</p>
</li>
<li><p>TreeNode *left;</p>
</li>
<li><p>TreeNode *right;</p>
</li>
<li><p>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</p>
</li>
<li><p>};</p>
</li>
<li><p>/<br>class Solution {<br>public:<br>  vector<int> postorderTraversal(TreeNode* root) {</int></p>
<pre><code>vector&lt;int&gt; ans;
if(root != NULL) {
    traversal(root, ans);
}
return ans;</code></pre><p>  }</p>
<p>  void traversal(TreeNode* node, vector<int> &amp;ans) {</int></p>
<pre><code>if(node-&gt;left != NULL) {
    traversal(node-&gt;left, ans);
}
if(node-&gt;right != NULL) {
    traversal(node-&gt;right, ans);
}
ans.push_back(node-&gt;val);</code></pre><p>  }<br>};</p>
</li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-红黑树" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-红黑树.html">红黑树</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-红黑树.html" class="article-date">
  <time datetime="2019-08-01T01:01:08.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>treeMap左旋<br>//Rotate Left<br>private void rotateLeft(Entry&lt;K,V&gt; p) {<br>    if (p != null) {<br>        Entry&lt;K,V&gt; r = p.right;<br>        p.right = r.left;<br>        if (r.left != null)<br>            r.left.parent = p;<br>        r.parent = p.parent;<br>        if (p.parent == null)<br>            root = r;<br>        else if (p.parent.left == p)<br>            p.parent.left = r;<br>        else<br>            p.parent.right = r;<br>        r.left = p;<br>        p.parent = r;<br>    }<br>}</p>
<p>treeMap右旋<br>//Rotate Right<br>private void rotateRight(Entry&lt;K,V&gt; p) {<br>    if (p != null) {<br>        Entry&lt;K,V&gt; l = p.left;<br>        p.left = l.right;<br>        if (l.right != null) l.right.parent = p;<br>        l.parent = p.parent;<br>        if (p.parent == null)<br>            root = l;<br>        else if (p.parent.right == p)<br>            p.parent.right = l;<br>        else p.parent.left = l;<br>        l.right = p;<br>        p.parent = l;<br>    }<br>}</p>
<p>treeMap寻找节点后继<br>// 寻找节点后继函数successor()<br>static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {<br>    if (t == null)<br>        return null;<br>    else if (t.right != null) {// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素<br>        Entry&lt;K,V&gt; p = t.right;<br>        while (p.left != null)<br>            p = p.left;<br>        return p;<br>    } else {// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先<br>        Entry&lt;K,V&gt; p = t.parent;<br>        Entry&lt;K,V&gt; ch = t;<br>        while (p != null &amp;&amp; ch == p.right) {<br>            ch = p;<br>            p = p.parent;<br>        }<br>        return p;<br>    }<br>}</p>
<p>get()方法<br>get(Object key)方法根据指定的key值返回对应的value，该方法调用<br>了getEntry(Object key)得到相应的entry，然后返回entry.value。<br>因此getEntry()是算法的核心。算法思想是根据key的自然顺序<br>（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。<br>//getEntry()方法<br>final Entry&lt;K,V&gt; getEntry(Object key) {<br>    ……<br>    if (key == null)//不允许key值为null<br>        throw new NullPointerException();<br>    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序<br>    Entry&lt;K,V&gt; p = root;<br>    while (p != null) {<br>        int cmp = k.compareTo(p.key);<br>        if (cmp &lt; 0)//向左找<br>            p = p.left;<br>        else if (cmp &gt; 0)//向右找<br>            p = p.right;<br>        else<br>            return p;<br>    }<br>    return null;<br>}</p>
<p>put()方法<br>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，<br>看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则<br>会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改<br>变某些节点的颜色）。<br>public V put(K key, V value) {<br>    ……<br>    int cmp;<br>    Entry&lt;K,V&gt; parent;<br>    if (key == null)<br>        throw new NullPointerException();<br>    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序<br>    do {<br>        parent = t;<br>        cmp = k.compareTo(t.key);<br>        if (cmp &lt; 0) t = t.left;//向左找<br>        else if (cmp &gt; 0) t = t.right;//向右找<br>        else return t.setValue(value);<br>    } while (t != null);<br>    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry<br>    if (cmp &lt; 0) parent.left = e;<br>    else parent.right = e;<br>    fixAfterInsertion(e);//调整<br>    size++;<br>    return null;<br>}</p>
<p>//红黑树调整函数fixAfterInsertion()<br>private void fixAfterInsertion(Entry&lt;K,V&gt; x) {<br>    x.color = RED;<br>    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {<br>        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {<br>            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));<br>            if (colorOf(y) == RED) {<br>                setColor(parentOf(x), BLACK);              // 情况1<br>                setColor(y, BLACK);                        // 情况1<br>                setColor(parentOf(parentOf(x)), RED);      // 情况1<br>                x = parentOf(parentOf(x));                 // 情况1<br>            } else {<br>                if (x == rightOf(parentOf(x))) {<br>                    x = parentOf(x);                       // 情况2<br>                    rotateLeft(x);                         // 情况2<br>                }<br>                setColor(parentOf(x), BLACK);              // 情况3<br>                setColor(parentOf(parentOf(x)), RED);      // 情况3<br>                rotateRight(parentOf(parentOf(x)));        // 情况3<br>            }<br>        } else {<br>            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));<br>            if (colorOf(y) == RED) {<br>                setColor(parentOf(x), BLACK);              // 情况4<br>                setColor(y, BLACK);                        // 情况4<br>                setColor(parentOf(parentOf(x)), RED);      // 情况4<br>                x = parentOf(parentOf(x));                 // 情况4<br>            } else {<br>                if (x == leftOf(parentOf(x))) {<br>                    x = parentOf(x);                       // 情况5<br>                    rotateRight(x);                        // 情况5<br>                }<br>                setColor(parentOf(x), BLACK);              // 情况6<br>                setColor(parentOf(parentOf(x)), RED);      // 情况6<br>                rotateLeft(parentOf(parentOf(x)));         // 情况6<br>            }<br>        }<br>    }<br>    root.color = BLACK;<br>}</p>
<p>remove()函数<br>remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p>
<p>getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。</p>
<p>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p>
<p>删除点p的左右子树都为空，或者只有一棵子树非空。<br>删除点p的左右子树都非空。<br>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）。</p>
<p>基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下：<br>// 红黑树entry删除函数deleteEntry()<br>private void deleteEntry(Entry&lt;K,V&gt; p) {<br>    modCount++;<br>    size–;<br>    if (p.left != null &amp;&amp; p.right != null) {// 2. 删除点p的左右子树都非空。<br>        Entry&lt;K,V&gt; s = successor(p);// 后继<br>        p.key = s.key;<br>        p.value = s.value;<br>        p = s;<br>    }<br>    Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);<br>    if (replacement != null) {// 1. 删除点p只有一棵子树非空。<br>        replacement.parent = p.parent;<br>        if (p.parent == null)<br>            root = replacement;<br>        else if (p == p.parent.left)<br>            p.parent.left  = replacement;<br>        else<br>            p.parent.right = replacement;<br>        p.left = p.right = p.parent = null;<br>        if (p.color == BLACK)<br>            fixAfterDeletion(replacement);// 调整<br>    } else if (p.parent == null) {<br>        root = null;<br>    } else { // 1. 删除点p的左右子树都为空<br>        if (p.color == BLACK)<br>            fixAfterDeletion(p);// 调整<br>        if (p.parent != null) {<br>            if (p == p.parent.left)<br>                p.parent.left = null;<br>            else if (p == p.parent.right)<br>                p.parent.right = null;<br>            p.parent = null;<br>        }<br>    }<br>}</p>
<p>private void fixAfterDeletion(Entry&lt;K,V&gt; x) {<br>    while (x != root &amp;&amp; colorOf(x) == BLACK) {<br>        if (x == leftOf(parentOf(x))) {<br>            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));<br>            if (colorOf(sib) == RED) {<br>                setColor(sib, BLACK);                   // 情况1<br>                setColor(parentOf(x), RED);             // 情况1<br>                rotateLeft(parentOf(x));                // 情况1<br>                sib = rightOf(parentOf(x));             // 情况1<br>            }<br>            if (colorOf(leftOf(sib))  == BLACK &amp;&amp;<br>                colorOf(rightOf(sib)) == BLACK) {<br>                setColor(sib, RED);                     // 情况2<br>                x = parentOf(x);                        // 情况2<br>            } else {<br>                if (colorOf(rightOf(sib)) == BLACK) {<br>                    setColor(leftOf(sib), BLACK);       // 情况3<br>                    setColor(sib, RED);                 // 情况3<br>                    rotateRight(sib);                   // 情况3<br>                    sib = rightOf(parentOf(x));         // 情况3<br>                }<br>                setColor(sib, colorOf(parentOf(x)));    // 情况4<br>                setColor(parentOf(x), BLACK);           // 情况4<br>                setColor(rightOf(sib), BLACK);          // 情况4<br>                rotateLeft(parentOf(x));                // 情况4<br>                x = root;                               // 情况4<br>            }<br>        } else { // 跟前四种情况对称<br>            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));<br>            if (colorOf(sib) == RED) {<br>                setColor(sib, BLACK);                   // 情况5<br>                setColor(parentOf(x), RED);             // 情况5<br>                rotateRight(parentOf(x));               // 情况5<br>                sib = leftOf(parentOf(x));              // 情况5<br>            }<br>            if (colorOf(rightOf(sib)) == BLACK &amp;&amp;<br>                colorOf(leftOf(sib)) == BLACK) {<br>                setColor(sib, RED);                     // 情况6<br>                x = parentOf(x);                        // 情况6<br>            } else {<br>                if (colorOf(leftOf(sib)) == BLACK) {<br>                    setColor(rightOf(sib), BLACK);      // 情况7<br>                    setColor(sib, RED);                 // 情况7<br>                    rotateLeft(sib);                    // 情况7<br>                    sib = leftOf(parentOf(x));          // 情况7<br>                }<br>                setColor(sib, colorOf(parentOf(x)));    // 情况8<br>                setColor(parentOf(x), BLACK);           // 情况8<br>                setColor(leftOf(sib), BLACK);           // 情况8<br>                rotateRight(parentOf(x));               // 情况8<br>                x = root;                               // 情况8<br>            }<br>        }<br>    }<br>    setColor(x, BLACK);<br>}</p>
<p>TreeSet<br>// TreeSet是对TreeMap的简单包装<br>public class TreeSet<e> extends AbstractSet<e><br>    implements NavigableSet<e>, Cloneable, java.io.Serializable<br>{<br>    ……<br>    private transient NavigableMap&lt;E,Object&gt; m;<br>    // Dummy value to associate with an Object in the backing Map<br>    private static final Object PRESENT = new Object();<br>    public TreeSet() {<br>        this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap<br>    }<br>    ……<br>    public boolean add(E e) {<br>        return m.put(e, PRESENT)==null;<br>    }<br>    ……<br>}</e></e></e></p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-test" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/uncategorized/2019-07-31-test.html">test</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/uncategorized/2019-07-31-test.html" class="article-date">
  <time datetime="2019-07-31T13:37:35.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/历史/">历史</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>test</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-second-commit" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/编程/2019-07-31-second-commit.html">second-commit</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/编程/2019-07-31-second-commit.html" class="article-date">
  <time datetime="2019-07-31T07:37:10.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程/">编程</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/历史/">历史</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>这里应该是安全的</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-hello-world" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/uncategorized/2019-07-31-hello-world.html">Hello World</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/uncategorized/2019-07-31-hello-world.html" class="article-date">
  <time datetime="2019-07-31T03:20:44.619Z" itemprop="datePublished">2019-07-31</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    
  </div>
  
  
</article>

  



</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.webp" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        天佑昨日
      
    </h3>
    <p class="avatar-slogan">
      明日不可求 幸得昨日来
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/数据结构与算法/" style="font-size: 20px;">数据结构与算法</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/技术/2019-08-01-排序.html">排序</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-01-二叉树.html">二叉树</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-01-红黑树.html">红黑树</a>
          </li>
        
          <li>
            <a href="/posts/uncategorized/2019-07-31-test.html">test</a>
          </li>
        
          <li>
            <a href="/posts/编程/2019-07-31-second-commit.html">second-commit</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://dretrtg.github.io/" title target='_blank'
        >dretrtg</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 dretrtg &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>
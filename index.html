<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>dretrtg的站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="dretrtg的站">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="dretrtg的站">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dretrtg的站">
  
    <link rel="alternate" href="/atom.xml" title="dretrtg的站" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.webp">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
  <script>
  let antiquityStorage = window.sessionStorage.getItem('antiquitySessionStorage');
  if (antiquityStorage == '' || antiquityStorage == null) {
    var antiquityLoader = '<div id="loaderbox"><div class="loader"><div class="load-roll"><div class="load-top"></div><div class="load-right"></div><div class="load-bottom"></div></div></div></div>';
    document.write(antiquityLoader);
    document.body.style.overflow = 'hidden'
  }
  </script>
</head>
</html>
<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-Java-Web" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-08-Java-Web.html">Java Web</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-08-Java-Web.html" class="article-date">
  <time datetime="2019-08-08T02:44:27.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>一、Servlet/JSP/Web<br>1、什么是Servlet<br>    Servlet三种实现方式：<br>        实现javax.servlet.Servlet接口<br>        继承javax.servlet.GenericServlet类<br>        继承javax.servlet.http.HttpServlet类</p>
<p>　　通常会去继承HttpServlet类来完成Servlet。<br>2、Tomcat容器等级<br>Tomcat容器分为4个等级，Servlet容器管理Context容器，一个Context对应一个Web工程。<br>3、Servlet执行流程<br>浏览器请求<br>    浏览器向服务器请求时，服务器不会直接执行我们的类，而是到 web.xml 里寻找路径名 ① 浏览器输入访问路径后，携带了请求行，头，体 ② 根据访问路径找到已注册的 servlet 名称 ③ 根据映射找到对应的 servlet 名 ④ 根据根据 servlet 名找到我们全限定类名，既我们自己写的类<br>服务器创建对象<br>    ① 服务器找到全限定类名后，通过反射创建对象，同时也创建了 servletConfig，里面存放了一些初始化信息（注意服务器只会创建一次 servlet 对象，所以 servletConfig 也只有一个）<br>调用init方法<br>    ① 对象创建好之后，首先要执行 init 方法，但是我们发现我们自定义类下没有 init 方法，所以程序会到其父类 HttpServlet 里找 ② 我们发现 HttpServlet 里也没有 init 方法，所以继续向上找，既向其父类 GenericServlet 中继续寻找,在 GenericServlet 中我们发现了 init 方法，则执行 init 方法（对接口 Servlet 中的 init 方法进行了重写）<br>调用service方法<br>    接着，服务器会先创建两个对象：ServletRequest 请求对象和 ServletResponse 响应对象，用来封装浏览器的请求数据和封装向浏览器的响应数据 ① 接着服务器会默认在我们写的类里寻找 service(ServletRequest req, ServletResponse res) 方法，但是 DemoServlet 中不存在，那么会到其父类中寻找 ② 到父类 HttpServlet 中发现有此方法，则直接调用此方法，并将之前创建好的两个对象传入 ③ 然后将传入的两个参数强转，并调用 HttpServlet 下的另外个 service 方法 ④ 接着执行 service(HttpServletRequest req, HttpServletResponse resp) 方法，在此方法内部进行了判断请求方式，并执行doGet和doPost，但是doGet和doPost方法已经被我们自己重写了，所以会执行我们重写的方法<br>向浏览器响应<br>4、Servlet生命周期<br>    void init(ServletConfig servletConfig) ：Servlet对象创建之后马上执行的初始化方法，只执行一次；<br>    void service(ServletRequest servletRequest, ServletResponse servletResponse) ：每次处理请求都是在调用这个方法，它会被调用多次；<br>    void destroy() ：在Servlet被销毁之前调用，负责释放 Servlet 对象占用的资源的方法；</p>
<pre><code>服务器启动时 ( web.xml中配置load-on-startup=1，默认为0 ) 或者第一次请求该 servlet 时，就会初始化一个 Servlet 对象，也就是会执行初始化方法 init(ServletConfig conf)

该 servlet 对象去处理所有客户端请求，在 service(ServletRequest req，ServletResponse res) 方法中执行

最后服务器关闭时，才会销毁这个 servlet 对象，执行 destroy() 方法。</code></pre><p>5、Tomcat装载Servlet的三种情况<br>    （1）Servlet容器启动时自动装载某些Servlet，实现它只需要在web.xml文件中的 <servlet></servlet> 之间添加以下代码：<br>    <load-on-startup>1</load-on-startup><br>　　其中，数字越小表示优先级越高。<br>    （2）客户端首次向某个Servlet发送请求<br>    （3）Servlet被修改后，Tomcat容器会重新装载Servlet<br>6、Jsp和Servlet的区别<br>    （1）不同之处：<br>    Servlet 在 Java 代码中通过 HttpServletResponse 对象动态输出 HTML 内容<br>    JSP 在静态 HTML 内容中嵌入 Java 代码，Java 代码被动态执行后生成 HTML 内容<br>    （2）各自特点<br>    Servlet 能够很好地组织业务逻辑代码，但是在 Java 源文件中通过字符串拼接的方式生成动态 HTML 内容会导致代码维护困难、可读性差<br>    JSP 虽然规避了 Servlet 在生成 HTML 内容方面的劣势，但是在 HTML 中混入大量、复杂的业务逻辑同样也是不可取的<br>    （3）通过MVC双剑合璧<br>        a.Web 浏览器发送 HTTP 请求到服务端，被 Controller(Servlet) 获取并进行处理（例如参数解析、请求转发）<br>        b.Controller(Servlet) 调用核心业务逻辑——Model部分，获得结果<br>        c.Controller(Servlet) 将逻辑处理结果交给 View（JSP），动态输出 HTML 内容<br>        d.动态生成的 HTML 内容返回到浏览器显示</p>
<pre><code>MVC 模式在 Web 开发中的好处是非常明显，它规避了 JSP 与 Servlet 各自的短板，Servlet 只负责业务逻辑而不会通过 out.append() 动态生成 HTML 代码；JSP 中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。</code></pre><p>7、tomcat和Servlet联系<br>    Tomcat是Web应用服务器，是一个Servlet/JSP容器。Tomcat 作为 Servlet 容器，负责处理客户请求，把请求传送给Servlet，并将Servlet的响应传送回给客户。而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。Servlet最常见的用途是扩展 Java Web 服务器功能，提供非常安全的，可移植的，易于使用的CGI替代品。</p>
<pre><code>Tomcat 将 http 请求文本接收并解析，然后封装成 HttpServletRequest 类型的 request 对象，所有的 HTTP 头数据读可以通过 request 对象调用对应的方法查询到。
Tomcat 同时会要响应的信息封装为 HttpServletResponse 类型的 response 对象，通过设置 response 属性就可以控制要输出到浏览器的内容，然后将 response 交给 tomcat，tomcat 就会将其变成响应文本的格式发送给浏览器</code></pre><p>8、cookie和session的区别<br>    由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是 Session。典型的场景比如购物车，当你点击下单按钮时，由于 HTTP 协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的 Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个 Session 是保存在服务端的，有一个唯一标识。在服务端保存Session 的方法很多，内存、数据库、文件都有。集群的时候也要考虑 Session 的转移，在大型的网站，一般会有专门的 Session 服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如 Memcached 之类的来放 Session。</p>
<pre><code>每次 HTTP 请求的时候，客户端都会发送相应的 Cookie 信息到服务端。实际上大多数的应用都是用 Cookie 来实现 Session 跟踪的，第一次创建 Session 的时候，服务端会在 HTTP 协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话 ID 发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次 HTTP 交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。


总结一下：
    Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
    Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。</code></pre><p>9、JavaEE中的三层结构和MVC<br>10、RESTful架构<br>    什么是REST<br>        可以总结为一句话：REST 是所有 Web 应用都应该遵守的架构设计指导原则。 Representational State Transfer，翻译是”表现层状态转化”。 面向资源是 REST 最明显的特征，对于同一个资源的一组不同的操作。资源是服务器上一个可命名的抽象概念，资源是以名词为核心来组织的，首先关注的是名词。REST要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。（7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS）<br>二、Spring<br>1、Spring IOC、AOP的理解、实现的原理，以及优点<br>    Spring的IoC容器是Spring的核心，Spring AOP是spring框架的重要组成部分</p>
<pre><code>IOC
    正常的情况下，比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象
    通过控制反转，把对象的创建不是通过new方式实现，而是交给Spring配置创建类对象

Spring IOC实现原理
    创建xml配置文件，配置要创建的对象类
    通过反射创建实例；
    获取需要注入的接口实现类并将其赋值给该接口

AOP
    在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待
Spring AOP实现原理
    动态代理（利用反射和动态编译将代理模式变成动态的）
    JDK的动态代理
    cglib动态代理</code></pre><p>2、什么是依赖注入，注入的方式有哪些<br>    DI（依赖注入）<br>        所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的控制。DI依赖注入，向类里面属性注入值 ，依赖注入不能单独存在，需要在IOC基础上完成操作。<br>        使用set方法注入<br>        使用有参构造注入<br>        使用接口注入<br>        注解注入(@Autowire)<br>3、BeanFactory和ApplicationContext的区别<br>BeanFactory<br>是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。</p>
<p>两者装载bean的区别<br>BeanFactory：在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化；<br>ApplicationContext：在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化；<br>我们该用BeanFactory还是ApplicationContent<br>BeanFactory 延迟实例化的优点：</p>
<p>应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势；</p>
<p>缺点：速度会相对来说慢一些。而且有可能会出现空指针异常的错误，而且通过bean工厂创建的bean生命周期会简单一些</p>
<p>ApplicationContext 不延迟实例化的优点：</p>
<p>所有的Bean在启动的时候都加载，系统运行的速度快；<br>在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的配置问题<br>建议web应用，在启动的时候就把所有的Bean都加载了。<br>缺点：把费时的操作放到系统启动中完成，所有的对象都可以预加载，缺点就是消耗服务器的内存</p>
<p>二、SpringMVC<br>1、SpringMVC工作原理<br>① 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。 <br>② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。 <br>③ 在这个地方Spring会通过HandlerAdapter对该处理进行封装。 <br>④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。 <br>⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。 <br>⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。 <br>⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。 <br>⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</p>
<p>组件及其作用<br>    （1）前端控制器 (DispatcherServlet)<br>        接收请求，响应结果，相当于转发器，中央处理器。负责调用系统的其他模块来真正处理用户的请求。 <br>        有了DispatcherServlet减少了其他组件之间的耦合度</p>
<pre><code>（2）处理器映射器 (HandlerMapping)
    作用：根据请求的 url 查找 Handler

（3）处理器 (Handler)
    注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样适配器才可以去正确执行 Handler

（4）处理器适配器 (HandlerAdapter)
    作用：按照特定规则（HandlerAdapter要求的规则）执行Handler。
（5）视图解析器 (ViewResolver)
    作用：进行视图解析，根据逻辑视图解析成真正的视图 (View)
（6）视图 (View)
    View 是一个接口实现类支持不同的 View 类型（jsp,pdf等等）

注意：只需要程序员开发，处理器和视图。</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Java虚拟机" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/uncategorized/2019-08-08-Java虚拟机.html">Java虚拟机</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/uncategorized/2019-08-08-Java虚拟机.html" class="article-date">
  <time datetime="2019-08-08T01:59:36.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Java-IOO" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-07-Java-IOO.html">Java IO</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-07-Java-IOO.html" class="article-date">
  <time datetime="2019-08-07T00:53:46.000Z" itemprop="datePublished">2019-08-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>Java 的 I/O 大概可以分成以下几类：<br>    磁盘操作：File<br>    字节操作：InputStream 和 OutputStream<br>    字符操作：Reader 和 Writer<br>    对象操作：Serializable<br>    网络操作：Socket<br>    新的输入/输出：NIO</p>
<p>1、磁盘操作<br>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<p>递归地输出一个目录下所有文件：</p>
<p>public static void listAllFiles(File dir)<br>{<br>    if (dir == null || !dir.exists()) {<br>        return;<br>    }<br>    if (dir.isFile()) {<br>        System.out.println(dir.getName());<br>        return;<br>    }<br>    for (File file : dir.listFiles()) {<br>        listAllFiles(file);<br>    }<br>}</p>
<p>2、字节操作<br>使用字节流操作进行文件复制：</p>
<p>public static void copyFile(String src, String dist) throws IOException<br>{<br>    FileInputStream in = new FileInputStream(src);<br>    FileOutputStream out = new FileOutputStream(dist);<br>    byte[] buffer = new byte[20 * 1024];<br>    // read() 最多读取 buffer.length 个字节<br>    // 返回的是实际读取的个数<br>    // 返回 -1 的时候表示读到 eof，即文件尾<br>    while (in.read(buffer, 0, buffer.length) != -1) {<br>        out.write(buffer);<br>    }<br>    in.close();<br>    out.close();<br>}</p>
<p>3、字符操作<br>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。<br>    InputStreamReader 实现从字节流解码成字符流；<br>    OutputStreamWriter 实现字符流编码成为字节流。</p>
<p>逐行输出文本文件的内容</p>
<p>public static void readFileContent(String filePath) throws IOException<br>{<br>    FileReader fileReader = new FileReader(filePath);<br>    BufferedReader bufferedReader = new BufferedReader(fileReader);<br>    String line;<br>    while ((line = bufferedReader.readLine()) != null) {<br>        System.out.println(line);<br>    }<br>    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象<br>    // 在调用 BufferedReader 的 close() 方法时会去调用 fileReader 的 close() 方法<br>    // 因此只要一个 close() 调用即可<br>    bufferedReader.close();<br>}</p>
<p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。<br>Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<p>4、Java序列化，如何实现序列化和反序列化，常见的序列化协议有哪些？<br>Java序列化定义<br>    （1）Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程；<br>    （2）序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。<br>    （3）反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。<br>    （4）本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</p>
<p>如何实现序列化和反序列化，底层怎么实现<br>    1、JDK类库中序列化和反序列化API<br>        （1）java.io.ObjectOutputStream：表示对象输出流；<br>        它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；<br>        （2）java.io.ObjectInputStream：表示对象输入流；<br>        它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回；<br>    2、实现序列化的要求<br>        只有实现了 Serializable 或 Externalizable 接口的类的对象才能被序列化，否则抛出异常！<br>    3、实现Java对象序列化与反序列化的方法<br>    4、JDK类库中序列化的步骤<br>        步骤一：创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流：<br>        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“D:\object.out”));<br>        步骤二：通过对象输出流的writeObject()方法写对象：<br>        oos.writeObject(new User(“xuliugen”, “123456”, “male”));<br>    5、JDK类库中反序列化的步骤<br>        步骤一：创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流：<br>        ObjectInputStream ois= new ObjectInputStream(new FileInputStream(“object.out”));<br>        步骤二：通过对象输出流的readObject()方法读取对象：<br>        User user = (User) ois.readObject();</p>
<p>相关注意事项<br>    1、序列化时，只对对象的状态进行保存，而不管对象的方法；<br>    2、当一个父类实现序列化，子类自动实现序列化，不需要显式实现 Serializable 接口；<br>    3、当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；<br>    4、并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：<br>        安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；<br>        资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；<br>    5、声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。<br>    6、序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：<br>        在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；<br>        在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。<br>    7、Java有很多基础类已经实现了serializable接口，比如String , Vector等。但是也有一些没有实现serializable接口的；<br>    8、如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；</p>
<p>ArrayList 序列化和反序列化的实现 ：ArrayList 中存储数据的数组是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<p>常见的序列化协议有哪些？<br>    COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大。<br>    CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。<br>    XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。<br>    SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。<br>    JSON（JavaScript Object Notation）<br>        相对于XML而言，序列化后的数据更加简洁。<br>        它具备javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。<br>        与XML相比，其协议比较简单，解析速度比较快。</p>
<p>5、同步和异步<br>同步IO：<br>    读写IO时代码等数据返回后才继续执行后续代码<br>    代码编写简单，CPU执行效率低<br>    JDK提供的java.io是同步IO<br>异步IO：<br>    读写IO时仅发出请求，然后立即执行后续代码<br>    代码编写复杂，CPU执行效率高<br>    JDK提供的java.nio是异步IO</p>
<p>7、BIO，NIO，AIO区别<br>    BIO（同步阻塞）：客户端和服务器连接需要三次握手，使用简单，但吞吐量小<br>    NIO（同步非阻塞）：客户端与服务器通过Channel连接，采用多路复用器轮询注册的Channel。提高吞吐量和可靠性。<br>    AIO（异步非阻塞）：NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。</p>
<p>8、Stock通信的伪代码实现流程<br>    服务器绑定端口：server = new ServerSocket(PORT)<br>    服务器阻塞监听：socket = server.accept()<br>    服务器开启线程：new Thread(Handle handle)<br>    服务器读写数据：BufferedReader PrintWriter<br>    客户端绑定IP和PORT：new Socket(IP_ADDRESS, PORT)<br>    客户端传输接收数据：BufferedReader PrintWriter</p>
<p>9、网络操作<br>Java 中的网络支持：<br>    InetAddress：用于表示网络上的硬件资源，即 IP 地址；<br>    URL：统一资源定位符；<br>    Sockets：使用 TCP 协议实现网络通信；<br>    Datagram：使用 UDP 协议实现网络通信。</p>
<p>InetAddress<br>没有公有构造函数，只能通过静态方法来创建实例。</p>
<p>InetAddress.getByName(String host);<br>InetAddress.getByAddress(byte[] address);</p>
<p>URL<br>可以直接从 URL 中读取字节流数据。</p>
<p>public static void main(String[] args) throws IOException<br>{<br>    URL url = new URL(“<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a>);<br>    // 字节流<br>    InputStream is = url.openStream();<br>    // 字符流<br>    InputStreamReader isr = new InputStreamReader(is, “utf-8”);<br>    BufferedReader br = new BufferedReader(isr);<br>    String line = br.readLine();<br>    while (line != null) {<br>        System.out.println(line);<br>        line = br.readLine();<br>    }<br>    br.close();<br>}</p>
<p>Sockets<br>    ServerSocket：服务器端类<br>    Socket：客户端类<br>    服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</p>
<p>什么是Socket？<br>    TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。<br>    套接字用（IP地址：端口号）表示。</p>
<pre><code>Socket是进程通讯的一种方式，即调用这个网络库的一些API函数实现分布在不同主机的相关进程之间的数据交换。

socket是网络编程的基础，本文用打电话来类比socket通信中建立TCP连接的过程。

    socket函数：表示你买了或者借了一部手机。 bind函数：告诉别人你的手机号码，让他们给你打电话。 listen函数：打开手机的铃声，而不是静音，这样有电话时可以立马反应。listen函数的第二个参数，最大连接数，表示最多有几个人可以同时拨打你的号码。不过我们的手机，最多只能有一个人打进来，要不然就提示占线。 connect函数：你的朋友知道了你的号码，通过这个号码来联系你。在他等待你回应的时候，不能做其他事情，所以connect函数是阻塞的。 accept函数：你听到了电话铃声，接电话，accept it！然后“喂”一声，你的朋友听到你的回应，知道电话已经打进去了。至此，一个TCP连接建立了。 read/write函数：连接建立后，TCP的两端可以互相收发消息，这时候的连接是全双工的。对应打电话中的电话煲。 close函数：通话完毕，一方说“我挂了”，另一方回应&quot;你挂吧&quot;，然后将连接终止。实际的close(sockfd)有些不同，它不止是终止连接，还把手机也归还，不在占有这部手机，就当是公用电话吧。

    注意到，上述连接是阻塞的，你一次只能响应一个用户的连接请求，但在实际网络编程中，一个服务器服务于多个客户，上述方案也就行不通了，怎么办？想一想10086，移动的声讯服务台，也是只有一个号码，它怎么能同时服务那么多人呢？可以这样理解，在你打电话到10086时，总服务台会让一个接线员来为你服务，而它自己却继续监听有没有新的电话接入。在网络编程中，这个过程类似于fork一个子进程，建立实际的通信连接，而主进程继续监听。10086的接线员是有限的，所以当连接的人数达到上线时，它会放首歌给你听，忙等待，直到有新的空闲接线员为止。 实际网络编程中，处理并发的方式还有select/poll/epoll等。</code></pre><p>Socket的特点<br>    Socket基于TCP链接，数据传输有保障<br>    Socket适用于建立长时间链接<br>    Socket编程通常应用于即时通讯</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Java并发编程" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-06-Java并发编程.html">Java并发编程</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-06-Java并发编程.html" class="article-date">
  <time datetime="2019-08-06T07:12:40.000Z" itemprop="datePublished">2019-08-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>一、并发编程<br>1、线程状态转换<br>    新建（New）<br>        创建后尚未启动。</p>
<pre><code>可运行（Runnable）
    可能正在运行，也可能正在等待 CPU 时间片。
    包含了操作系统线程状态中的 运行（Running ） 和 就绪（Ready）。

阻塞（Blocking）
    这个状态下，是在多个线程有同步操作的场景，比如正在等待另一个线程的 synchronized 块的执行释放，或者可重入的 synchronized 块里别人调用 wait() 方法，也就是线程在等待进入临界区。
    阻塞可以分为：等待阻塞，同步阻塞，其他阻塞

无限期等待（Waiting）
    等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。

限期等待（Timed Waiting）
    无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。
    调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用 “使一个线程睡眠” 进行描述。
    调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用 “挂起一个线程” 进行描述。
    睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。
    阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。

死亡（Terminated）
    线程因为 run 方法正常退出而自然死亡
    因为一个没有捕获的异常终止了 run 方法而意外死亡</code></pre><p>2、Java实现多线程的方式及三种方式的区别<br>    有三种使用线程的方法<br>        实现Runnable接口；<br>        实现Callable接口；<br>        继承Thread类。<br>    实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<pre><code>实现Runnable接口：
    需要实现run()方法；通过Thread调用start（）方法启动线程。

    public class MyRunnable implements Runnable {
        public void run() {
            // ...
        }
    }

    public static void main(String[] args) {
        MyRunnable instance = new MyRunnable();
        Thread thread = new Thread(instance);
        thread.start();
    }

实现Callable接口：
    与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

    public class MyCallable implements Callable&lt;Integer&gt; {
        public Integer call() {
            return 123;
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable mc = new MyCallable();
        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);
        Thread thread = new Thread(ft);
        thread.start();
        System.out.println(ft.get());
    }

继承Thread类:
    同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。

    public class MyThread extends Thread {
        public void run() {
        // ...
        }
    }
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        mt.start();
    }

实现接口 VS 继承 Thread
    实现接口会更好一些，因为：
        Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
        类可能只要求可执行就行，继承整个 Thread 类开销过大。

三种方式的区别
    实现 Runnable 接口可以避免 Java 单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。
    继承 Thread 类和实现 Runnable 方法启动线程都是使用 start() 方法，然后 JVM 虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行 run() 方法。
    实现 Callable 接口要实现 call() 方法，并且线程执行完毕后会有返回值。其他的两种都是重写 run() 方法，没有返回值。</code></pre><p>3、基础线程机制<br>    Executor<br>    Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。<br>    主要有三种 Executor：<br>        CachedThreadPool：一个任务创建一个线程；<br>        FixedThreadPool：所有任务只能使用固定大小的线程；<br>        SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p>
<pre><code>为什么引入Executor线程池框架？
    new Thread() 的缺点
        每次 new Thread() 耗费性能
        调用 new Thread() 创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。
        不利于扩展，比如如定时执行、定期执行、线程中断
    采用线程池的优点
        重用存在的线程，减少对象创建、消亡的开销，性能佳
        可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞
        提供定时执行、定期执行、单线程、并发数控制等功能

Daemon（守护线程）
Java 中有两类线程：User Thread (用户线程)、Daemon Thread (守护线程)
用户线程即运行在前台的线程，而守护线程是运行在后台的线程。

sleep()
    Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。
    sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

    public void run() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

yield（）
对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

public void run() {
    Thread.yield();
}

线程阻塞
    线程可以阻塞于四种状态：
        当线程执行 Thread.sleep() 时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断；
        当线程碰到一条 wait() 语句时，它会一直阻塞到接到通知 notify()、被中断或经过了指定毫秒时间为止（若制定了超时值的话）
        线程阻塞与不同 I/O 的方式有多种。常见的一种方式是 InputStream 的 read() 方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；
        线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得 synchronized 语句必须的锁时阻塞）。

    注意，并非所有的阻塞状态都是可中断的，以上阻塞状态的前两种可以被中断，后两种不会对中断做出反应</code></pre><p>4、中断<br>    InterruptedException<br>        通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<pre><code>    对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。

    public class InterruptExample {
        private static class MyThread1 extends Thread {
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                    System.out.println(&quot;Thread run&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new MyThread1();
        thread1.start();
        thread1.interrupt();
        System.out.println(&quot;Main run&quot;);
    }//输出Main run

interrupted()
    如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。
    但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。

    public class InterruptExample {
        private static class MyThread2 extends Thread {
            @Override
            public void run() {
                while (!interrupted()) {
                // ..
                }
            System.out.println(&quot;Thread end&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread2 = new MyThread2();
        thread2.start();
        thread2.interrupt();
    }//输出Thread end</code></pre><p>5、互斥同步<br>    Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<pre><code>synchronized
(1) 同步一个代码块

    public void func() {
        synchronized (this) {
        // ...
        }
    }

它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。
对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。

public class SynchronizedExample {
    public void func1() {
        synchronized (this) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}

public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e1.func1());
}//0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9

对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。

public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e2.func1());
}//0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9

（2）同步一个方法

    public synchronized void func () {
        // ...
    }

（3）同步一个类

    public void func() {
        synchronized (SynchronizedExample.class) {
        // ...
        }
    }

    作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。

    public class SynchronizedExample {
        public void func2() {
            synchronized (SynchronizedExample.class) {
                for (int i = 0; i &lt; 10; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        }
    }

    public static void main(String[] args) {
        SynchronizedExample e1 = new SynchronizedExample();
        SynchronizedExample e2 = new SynchronizedExample();
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(() -&gt; e1.func2());
        executorService.execute(() -&gt; e2.func2());
    }//0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9

（4）同步一个静态方法
    非静态同步函数的锁是：this
    静态的同步函数的锁是：字节码对象

ReentrantLock
    重入锁（ReentrantLock）是一种递归无阻塞的同步机制。

    public class LockExample {
        private Lock lock = new ReentrantLock();
        public void func() {
            lock.lock();
            try {
                for (int i = 0; i &lt; 10; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            } finally {
                lock.unlock(); // 确保释放锁，从而避免发生死锁。
            }
        }
    }

    public static void main(String[] args) {
        LockExample lockExample = new LockExample();
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(() -&gt; lockExample.func());
        executorService.execute(() -&gt; lockExample.func());
    }//0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9


    ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁，相比于 synchronized，它多了以下高级功能：
        1. 等待可中断
        当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
        2. 可实现公平锁
        公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。
        synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
        3. 锁绑定多个条件
        一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。

    synchronized 和 ReentrantLock 比较
        1. 锁的实现
        synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。
        2. 性能
        新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等。目前来看它和 ReentrantLock 的性能基本持平了，因此性能因素不再是选择 ReentrantLock 的理由。synchronized 有更大的性能优化空间，应该优先考虑 synchronized。
        3. 功能
        ReentrantLock 多了一些高级功能。
        4. 使用选择
        除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

    synchronized与lock的区别，使用场景。看过synchronized的源码没？
        （用法）synchronized（隐式锁）：在需要同步的对象中加入此控制，synchronized 可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。
        （用法）lock（显示锁）：需要显示指定起始位置和终止位置。一般使用 ReentrantLock 类做为锁，多个线程中必须要使用一个 ReentrantLock 类做为对象才能保证锁的生效。且在加锁和解锁处需要通过 lock() 和 unlock() 显示指出。所以一般会在 finally 块中写 unlock() 以防死锁。
        （性能）synchronized 是托管给 JVM 执行的，而 lock 是 Java 写的控制锁的代码。在 Java1.5 中，synchronize 是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用 Java 提供的 Lock 对象，性能更高一些。但是到了 Java1.6 ，发生了变化。synchronize 在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致 在 Java1.6 上 synchronize 的性能并不比 Lock 差。
        （机制）synchronized 原始采用的是 CPU 悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。Lock 用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是 CAS 操作（Compare and Swap）。

    CAS（compare and swap）
        是一种对内存中的共享数据进行操作的特殊指令。
        操作过程：
            首先，CPU 会将内存中将要被更改的数据与期望的值做比较。
            然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。
            最后，CPU 会将旧的数值返回。

    什么是乐观锁和悲观锁
        为什么需要锁（并发控制）
            在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题。
            典型的冲突有：
                丢失更新：一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户 A 把值从 6 改为 2，用户 B 把值从 2 改为 6，则用户 A 丢失了他的更新。
                脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户 A,B 看到的值都是6，用户 B 把值改为 2，用户 A 读到的值仍为 6。
            为了解决这些并发带来的问题。 我们需要引入并发控制机制。
        并发控制机制
            悲观锁：假定会发生并发冲突，独占锁，屏蔽一切可能违反数据完整性的操作。
            乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。</code></pre><p>6、线程之间的协作<br>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<p>join()<br>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。<br>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<pre><code>public class JoinExample {
    private class A extends Thread {
        @Override
        public void run() {
            System.out.println(&quot;A&quot;);
        }
    }
    private class B extends Thread {
        private A a;
        B(A a) {
            this.a = a;
        }
        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;B&quot;);
        }
    }
    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}

public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}</code></pre><p>wait() notify() notifyAll()<br>    调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify()（随机叫醒一个） 或者 notifyAll() （叫醒所有 wait 线程，争夺时间片的线程只有一个）来唤醒挂起的线程。<br>    它们都属于 Object 的一部分，而不属于 Thread。<br>    只能用在同步方法或者同步控制块中使用！否则会在运行时抛出 IllegalMonitorStateExeception。<br>    使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<p>await() signal() signalAll()<br>    java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。<br>    使用 Lock 来获取一个 Condition 对象。</p>
<p>sleep和wait有什么区别<br>    sleep 和 wait<br>        wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；<br>        wait() 会释放锁，sleep() 不会。<br>    有什么区别<br>        sleep() 方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。<br>        wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<p>7、线程不安全实例</p>
<p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值为 997 而不是 1000。</p>
<p>public class ThreadUnsafeExample {<br>    private int cnt = 0;<br>    public void add() {<br>        cnt++;<br>    }<br>    public int get() {<br>        return cnt;<br>    }<br>}</p>
<p>public static void main(String[] args) throws InterruptedException {<br>    final int threadSize = 1000;<br>    ThreadUnsafeExample example = new ThreadUnsafeExample();<br>    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    for (int i = 0; i &lt; threadSize; i++) {<br>        executorService.execute(() -&gt; {<br>            example.add();<br>            countDownLatch.countDown();<br>        });<br>    }<br>    countDownLatch.await();<br>    executorService.shutdown();<br>    System.out.println(example.get());<br>}</p>
<p>8、线程安全<br>线程安全定义<br>一个类可以被多个线程安全调用时就是线程安全的。</p>
<p>线程安全分类<br>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<p>（1） 不可变<br>不可变（Immutable）的对象一定是线程安全的<br>不可变的类型：<br>    final 关键字修饰的基本数据类型；<br>    String<br>    枚举类型<br>    Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。</p>
<p>（2） 绝对线程安全<br>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
<p>（3）相对线程安全<br>相对的线程安全需要保证对这个对象单独的操作是线程安全的<br>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p>
<p>（4） 线程兼容<br>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p>
<p>（5） 线程对立<br>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的</p>
<p>线程安全的实现方法<br>    （1）阻塞同步<br>        synchronized和ReentrantLock。<br>    （2）非阻塞同步<br>        乐观锁<br>    （3）无同步方案<br>        a.可重入代码<br>        b.栈封闭。多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在栈中，属于线程私有的。<br>        c.线程本地存储（ThreadLocal）</p>
<p>9、多线程开发良好实践<br>    给线程起个有意义的名字，这样可以方便找 Bug。<br>    缩小同步范围，例如对于 synchronized，应该尽量使用同步块而不是同步方法。<br>    多用同步类少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现对复杂的控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。<br>    多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。<br>    使用本地变量和不可变类来保证线程安全。<br>    使用线程池而不是直接创建 Thread 对象，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。<br>    使用 BlockingQueue 实现生产者消费者问题。</p>
<p>10、线程池<br>    初始化线程池<br>        newFixedThreadPool() 说明：初始化一个指定线程数的线程池，其中 corePoolSize == maxiPoolSize，使用 LinkedBlockingQuene 作为阻塞队列 特点：即使当线程池没有可执行任务时，也不会释放线程。<br>        newCachedThreadPool() 说明：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到 Integer.MAX_VALUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列； 特点：在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。<br>        newSingleThreadExecutor() 说明：初始化只有一个线程的线程池，内部使用 LinkedBlockingQueue 作为阻塞队列。 特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行<br>        newScheduledThreadPool() 特点：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</p>
<p>二、面试指南<br>1、volatile与synchronized区别<br>    （1）仅靠volatile不能保证线程的安全性。（原子性）<br>        ① volatile 轻量级，只能修饰变量。synchronized重量级，还可修饰方法<br>        ② volatile 只能保证数据的可见性，不能用来同步，因为多个线程并发访问 volatile 修饰的变量不会阻塞。<br>        synchronized 不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢 synchronized 锁对象时，会出现阻塞。<br>    （2）线程安全性<br>        线程安全性包括两个方面，①可见性。②原子性。<br>        从上面自增的例子中可以看出：仅仅使用 volatile 并不能保证线程安全性。而 synchronized 则可实现线程的安全性。</p>
<p>2、什么是线程池？如果让你设计一个动态大小的线程池，如何设计，应该有哪些方法？线程池创建的方式？<br>    什么是线程池？<br>        线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<pre><code>设计一个动态大小的线程池，如何设计，应该有哪些方法
    一个线程池包括以下四个基本组成部分：
        线程管理器 (ThreadPool)：用于创建并管理线程池，包括创建线程，销毁线程池，添加新任务；
        工作线程 (PoolWorker)：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
        任务接口 (Task)：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
        任务队列 (TaskQueue)：用于存放没有处理的任务。提供一种缓冲机制；

    所包含的方法
        private ThreadPool() 创建线程池
        public static ThreadPool getThreadPool() 获得一个默认线程个数的线程池
        public void execute(Runnable task) 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定
        public void execute(Runnable[] task) 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定
        public void destroy() 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁
        public int getWorkThreadNumber() 返回工作线程的个数
        public int getFinishedTasknumber() 返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成
        public void addThread() 在保证线程池中所有线程正在执行，并且要执行线程的个数大于某一值时。增加线程池中线程的个数
        public void reduceThread() 在保证线程池中有很大一部分线程处于空闲状态，并且空闲状态的线程在小于某一值时，减少线程池中线程的个数

线程池四种创建方式
    Java 通过 Executors 提供四种线程池，分别为：
        new CachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
        new FixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
        new ScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
        new SingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</code></pre><p>3、什么是并发、并行<br>并发<br>    并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。<br>    如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。<br>    多个线程操作相同的资源，保证线程安全，合理使用资源</p>
<p>并行<br>    并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)<br>    比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。<br>    服务能同时处理很多请求，提高程序性能    </p>
<p>4、什么是线程安全<br>当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。——来自《深入理解Java虚拟机》</p>
<p>如何保证线程安全<br>    对变量使用volitate<br>    对程序段进行加锁（synchronized，lock）</p>
<p>非线程安全并不是多线程环境下就不能使用。注意我上面有说到：多线程操作同一个对象。注意是同一个对象。比如最上面那个模拟，就是在主线程中 new 的一个 ArrayList 然后多个线程操作同一个 ArrayList 对象。</p>
<p>如果是每个线程中 new 一个 ArrayList，而这个 ArrayList 只在这一个线程中使用，那么肯定是没问题的。</p>
<ol start="5">
<li><p>什么是线程？线程和进程有什么区别？为什么要使用多线程<br>（1）线程和进程<br> 进程是操作系统分配资源的最小单位<br> 线程是CPU调度的最小单位<br>（2）使用线程的原因<br> 使用多线程可以减少程序的响应时间；<br> 与进程相比，线程的创建和切换开销更小；<br> 多核电脑上，可以同时执行多个线程，提高资源利用率；<br> 简化程序的结构，使程序便于理解和维护</p>
</li>
<li><p>多线程共用一个数据变量需要注意什么？<br> 当我们在线程对象（Runnable）中定义了全局变量，run方法会修改该变量时，如果有多个线程同时使用该线程对象，那么就会造成全局变量的值被同时修改，造成错误.<br> ThreadLocal 是JDK引入的一种机制，它用于解决线程间共享变量，使用 ThreadLocal 声明的变量，即使在线程中属于全局变量，针对每个线程来讲，这个变量也是独立的。<br> volatile 变量每次被线程访问时，都强迫线程从主内存中重读该变量的最新值，而当该变量发生修改变化时，也会强迫线程将最新的值刷新回主内存中。这样一来，不同的线程都能及时的看到该变量的最新值。</p>
</li>
</ol>
<p>7、内存泄漏与溢出<br>Java 会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。</p>
<p>在 Java 语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值 null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。</p>
<p>内存泄露：是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示 Out of memory。<br>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。</p>
<p>8、如何减少线程上下文切换<br>使用多线程时，不是多线程能提升程序的执行速度，使用多线程是为了更好地利用 CPU 资源！<br>程序在执行时，多线程是 CPU 通过给每个线程分配 CPU 时间片来实现的，时间片是CPU分配给每个线程执行的时间，因时间片非常短，所以CPU 通过不停地切换线程执行。<br>线程不是越多就越好的，因为线程上下文切换是有性能损耗的，在使用多线程的同时需要考虑如何减少上下文切换<br>    无锁并发编程。多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照Hash取模分段，不同的线程处理不同段的数据<br>    CAS算法。Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。<br>    控制线程数量。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态<br>    协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换<br>    协程可以看成是用户态自管理的“线程”。不会参与CPU时间调度，没有均衡分配到时间。非抢占式的</p>
<pre><code>如果是IO密集型的话，线程可以多一些。
如果是CPU密集型的话，线程不宜太多。</code></pre><p>9、线程间通信和进程间通信<br>线程间通信<br>    synchronized同步<br>    while轮询<br>    wait/notify机制<br>    管道通信<br>进程间通信<br>    管道<br>    命名管道<br>    信号<br>    消息队列<br>    共享内存<br>    内存映射<br>    信号量<br>    套接口</p>
<p>10、什么是同步和异步，阻塞和非阻塞？<br>同步<br>    在发出一个同步调用时，在没有得到结果之前，该调用就不返回。<br>    例如：按下电饭锅的煮饭按钮，然后等待饭煮好，把饭盛出来，然后再去炒菜。<br>异步<br>    在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了。<br>    例如：按下电钮锅的煮饭按钮，直接去炒菜或者做别的事情，当电饭锅“滴滴滴”响的时候，再回去把饭盛出来。显然，异步式编程要比同步式编程高效得多。<br>阻塞<br>    调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>    例子：你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果<br>非阻塞<br>    在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>    例子：你打电话问书店老板有没有《分布式系统》这本书，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Java集合框架" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-06-Java集合框架.html">Java集合框架</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-06-Java集合框架.html" class="article-date">
  <time datetime="2019-08-06T00:24:26.000Z" itemprop="datePublished">2019-08-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>一、概述<br>    主要有三大类：Collection（接口）、Map(接口)、集合工具类</p>
<pre><code>Collection
    ArrayList:线程不同步。默认初始容量为10，当数组大小不足时容量扩大为1.5倍，如果需要多线程并发访问，用户可以手动同步，也可以用vector代替。
    LinkedList:线程不同步，双向链接实现。当需要使用栈或者队列时，可以考虑使用LinkedList，关于栈或队列，现在的首选时ArrayDeque，当作栈或队列使用时比LinkedList性能更好。
    Vector：线程同步。默认初始容量为10，当数组大小不足时容量扩大为2倍。它的同步是通过Iterator方法加synchronized实现的。
    TreeSet：线程不同步，默认元素自然顺序排列，可以通过Comparator改变排序。
    HashSet：线程不同步，提供的方法基本都是调用HashMap方法，两者本质一样。
    Set：Set是一种不包含重复元素的Collection，Set最多只有一个null元素。

Map
    TreeMap：线程不同步，基于红黑树实现，能把它保存的记录根据键排序，默认是按键值的升序排序，其方法时间复杂度都为log（n）。
    HashTable：线程安全。不能存储NULL的key和value。
    HashMap：线程不同步。根据key的hashcode进行存储，内部使用静态内部类Node数组进行存储，默认初始大小为16，每次扩大一倍，当单个桶中元素个数大于等于8时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现，以此防止hshCode攻击。
    LinkedHashMap：保存了记录的插入顺序。

工具类
    Collections、Arrays
    Comparable、Comparator</code></pre><p>二、深入源码分析<br>ArrayList<br>    1、概览<br>        实现了 RandomAccess 接口，因此支持随机访问，这是理所当然的，因为 ArrayList 是基于数组实现的。</p>
<pre><code>    public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable

    数组默认大小为10

    private static final int DEFAULT_CAPACITY = 10;

2、序列化
    ArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 重写了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。

    transient Object[] elementData; // non-private to simplify nested class access

3、扩容
    扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。

4、删除元素
    需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上。</code></pre><p>Vector<br>    1、同步<br>        实现与ArrayList类似，但是使用了synchronized进行同步<br>    2、ArrayList与Vector<br>        vector是同步的，开销比ArrayList要大，访问速度慢。最好使用ArrayList，同步可以手动控制。<br>        Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。</p>
<p>LinkedList<br>    1、概述<br>        LinkedList底层是基于双向链表实现的<br>    2、add()<br>        末尾插入元素是常数时间；在指定位置插入元素需要先通过线性查找找到具体位置，然后修改相关引用完成插入<br>    3、remove()<br>        先找到要删除元素的引用；修改引用完成删除（通过unlink（Node<e>x）方法完成）。<br>    4、get()<br>        使用二分查找看index离size中间距离判断是正序查还是倒序查。<br>    5、总结<br>        LinkedList插入删除都是移动指针效率很高。<br>        查找需要遍历查询，效率很低。<br>    6、ArrayList与LinkedList<br>        ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；<br>        ArrayList 支持随机访问，LinkedList 不支持；<br>        LinkedList 在任意位置添加删除元素更快。</e></p>
<p>HashMap<br>    1、存储结构<br>        对于 JDK1.8 之后的 HashMap 底层在解决哈希冲突的时候，就不单单是使用数组加上单链表的组合了，因为当处理如果 hash 值冲突较多的情况下，链表的长度就会越来越长，此时通过单链表来寻找对应 Key 对应的 Value 的时候就会使得时间复杂度达到 O(n)，因此在 JDK1.8 之后，在链表新增节点导致链表长度超过 TREEIFY_THRESHOLD = 8 的时候，就会在添加元素的同时将原来的单链表转化为红黑树。</p>
<pre><code>原因：</code></pre><p>　　        红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。<br>        还有选择6和8的原因是：<br>　　        中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。<br>            理想情况下，在随机哈希代码下，桶中的节点频率遵循泊松分布，桶的长度超过8的概率很小，因此依据概率统计选择8作为阈值。</p>
<pre><code>    HashMap是数组+链表+红黑树实现的

    hashMap存储的是键值对Node
2、确定哈希桶数组索引位置
    先确定一个键值对所在的桶下标
    （1）计算key的hash值
    （2）取模
3、put()
    ①.判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；

    ②.根据键值 key 计算 hash 值得到插入的数组索引i，如果 table[i]==null，直接新建节点添加，转向 ⑥，如果table[i] 不为空，转向 ③；

    ③.判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 ④，这里的相同指的是 hashCode 以及 equals；

    ④.判断table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 ⑤；

    ⑤.遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；

    ⑥.插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。

    public V put(K key, V value) {
    // 对key的hashCode()做hash
        return putVal(hash(key), key, value, false, true);
    }

    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
           boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        // 步骤①：tab为空则创建
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
            // 步骤②：计算index，并对null做处理 
        if ((p = tab[i = (n - 1) &amp; hash]) == null) 
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            // 步骤③：节点key存在，直接覆盖value
            if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            // 步骤④：判断该链为红黑树
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            // 步骤⑤：该链为链表
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key,value,null);
                        //链表长度大于8转换为红黑树进行处理
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  
                            treeifyBin(tab, hash);
                            break;
                        }
                        // key已经存在直接覆盖value
                        if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) 
                            break;
                            p = e;
                        }
                }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        // 步骤⑥：超过最大容量 就扩容
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

4、线程安全性
    在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。
5、HashMap与HashTable
    HashTable 使用 synchronized 来进行同步。
    HashMap 可以插入键为 null 的 Entry。
    HashMap 的迭代器是 fail-fast 迭代器。
    HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
6、小结
    扩容是一个特别耗性能的操作，所以当程序员在使用 HashMap 的时候，估算 map 的大小，初始化的时候给一个大致的数值，避免 map 进行频繁的扩容。
    负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。
    HashMap 是线程不安全的，不要在并发的环境中同时操作 HashMap，建议使用 ConcurrentHashMap。
    JDK1.8 引入红黑树大程度优化了 HashMap 的性能。</code></pre><p>ConcurrentHashMap<br>    ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。<br>    默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<p>三、容器中的设计模式<br>迭代器模式<br>    Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。<br>适配器模式<br>    java.util.Arrays.asList() 可以把数组类型转换为 List 类型。<br>四、面试指南<br>    1. ArrayList和LinkedList区别<br>        ArrayList 和 LinkedList 可想从名字分析，它们一个是 Array (动态数组) 的数据结构，一个是 Link (链表) 的数据结构，此外，它们两个都是对 List 接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列；</p>
<pre><code>    当随机访问 List 时（get和set操作），ArrayList 比 LinkedList的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找；

    当对数据进行增加和删除的操作时（add 和 remove 操作），LinkedList 比 ArrayList 的效率更高，因为 ArrayList 是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动；

    从利用效率来看，ArrayList 自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用；

    ArrayList 主要空间开销在于需要在 List 列表预留一定空间；而 LinkList 主要控件开销在于需要存储结点信息以及结点指针信息。

    ArrayList、LinkedList 和 Vector如何选择？

        当对数据的主要操作为索引或只在集合的末端增加、删除元素时，使用 ArrayList 或 Vector 效率比较高；
        当对数据的操作主要为制定位置的插入或删除操作时，使用 LinkedList 效率比较高；
        当在多线程中使用容器时（即多个线程会同时访问该容器），选用 Vector 较为安全；

2. HashMap和HashTable区别，HashMap的key类型
Hash Map和HashTable的区别

    Hashtable 的方法是同步的，HashMap 非同步，所以在多线程场合要手动同步

    Hashtable 不允许 null 值 (key 和 value 都不可以)，HashMap 允许 null 值( key 和 value 都可以)。

    两者的遍历方式大同小异，Hashtable 仅仅比 HashMap 多一个 elements 方法。

    Hashtable 和 HashMap 都能通过 values() 方法返回一个 Collection ，然后进行遍历处理。

    两者也都可以通过 entrySet() 方法返回一个 Set ， 然后进行遍历处理。

    HashTable 使用 Enumeration，HashMap 使用 Iterator。

    哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。

    Hashtable 中 hash 数组默认大小是11，增加的方式是 old*2+1。HashMap 中 hash 数组的默认大小是16，而且一定是 2 的指数。

    HashTable 基于 Dictionary 类，而 HashMap 基于 AbstractMap 类

HashMap中的key可以是任何对象或数据类型吗
    可以为null，但不能是可变对象，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。
    如果可变对象在 HashMap 中被用作键，那就要小心在改变对象状态的时候，不要改变它的哈希值了。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。

    HashTable是线程安全的么
        HashTable 是线程安全的，其实现是在对应的方法上添加了 synchronized 关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以现在如果为了保证线程安全的话，使用 CurrentHashMap。

3. HashMap和ConcurrentHashMap
    HashMap和Concurrent HashMap区别？
        HashMa p是非线程安全的，CurrentHashMap 是线程安全的。
        ConcurrentHashMap 将整个 Hash 桶进行了分段 segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁。
        ConcurrentHashMap 让锁的粒度更精细一些，并发性能更好。
    ConcurrentHashMap 线程安全吗， ConcurrentHashMap如何保证 线程安全？
        HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable 的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是 ConcurrentHashMap 所使用的分段锁，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。
        get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空的才会加锁重读。get 方法里将要使用的共享变量都定义成 volatile，如用于统计当前 Segement 大小的 count 字段和用于存储值的 HashEntry 的 value。定义成 volatile 的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value，所以可以不用加锁。
        put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。
            插入操作需要经历两个步骤：（1）判断是否需要对 Segment 里的 HashEntry 数组进行扩容；（2）定位添加元素的位置然后放在HashEntry数组里。
4、Hash冲突解决办法
    链地址法
    开放地址法（向后一位）
        线性探测
        平方探测
        二次哈希
    再哈希法
5、hashmap 始终将自己的桶保持在2n，这是为什么？
    计算机里位运算是基本运算，位运算效率远高于取余运算。在hashmap里获取要存放的数组下标需要进行取模，为提高效率采用位运算
        举个例子：2n 转换成二进制就是 1+n 个 0，减 1 之后就是 0+n个1，如16 -&gt; 10000，15 -&gt; 01111
        那么根据 &amp; 位运算的规则，都为 1 (真)时，才为 1，那 0≤运算后的结果≤15，假设 h &lt;= 15，那么运算后的结果就是 h 本身，h &gt;15，运算后的结果就是最后四位二进制做 &amp; 运算后的值，最终，就是 % 运算后的余数。
        当容量一定是 2n 时，h &amp; (length - 1) == h % length</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-Java基础" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-02-Java基础.html">Java基础</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-02-Java基础.html" class="article-date">
  <time datetime="2019-08-02T03:52:43.000Z" itemprop="datePublished">2019-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>一、基本概念<br>1、Java程序初始化顺序<br>当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建对象。<br>-初始化三原则<br>    静态变量优先于非静态变量初始化，静态变量只初始化一次，非静态变量可能会初始化多次；<br>    父类优先于子类进行初始化；<br>    按照成员变量定义顺序进行初始化，散布在各方法中的变量定义依然在方法调用前初始化<br>-加载顺序<br>    父类（静态变量、静态语句块）<br>    子类（静态变量、静态语句块）<br>    父类（实例变量、普通语句块）<br>    父类（构造函数）<br>    子类（实例变量、普通语句块）<br>    子类（构造函数）<br>2、Java和C++区别<br>    Java是纯粹的面向对象语言，所有对象继承java.lang.Object，C++既面向对象也面向过程<br>    Java通过虚拟机实现跨平台特性，C++依赖特定平台<br>    Java没有指针<br>    Java支持自动垃圾回收，C++手动回收<br>    Java不支持多重继承，只能通过多个接口达到目的，C++支持<br>    Java不支持操作符重载<br>    Java内置线程支持，C++需要依赖第三方库<br>    Java的goto是保留字，但是不可用，c++可以使用goto<br>    Java不支持条件编译，C++通过#ifdef#ifndef等预处理命令从而实现条件编译<br>3、反射<br>    反射 (Reflection) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过 Class 获取 class 信息称之为反射（Reflection）<br>    程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p>
<p>　　反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。<br>    Java 反射框架主要提供以下功能：</p>
<p>　　1. 在运行时判断任意一个对象所属的类</p>
<p>　　2. 在运行时构造任意一个类的对象</p>
<p>　　3. 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用 private 方法）</p>
<p>　　4. 在运行时调用任意一个对象的方法</p>
<p>　　重点：是运行时而不是编译时<br>4、注解<br>    注解其实就是代码中的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相对应的处理。<br>    例如：我们以前编写 Servlet 的时候，需要在 web.xml 文件配置具体的信息。我们使用了注解以后，可以直接在 Servlet 源代码上，增加注解…Servlet 就被配置到 Tomcat 上了。也就是说，注解可以给类、方法上注入信息。<br>    在SSM中注解扫描在applicationContext.xml 配置</p>
<pre><code>自定义注解类编写规则
    Annotation 型定义为 @interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口，并且不能再去继承别的类或是接口.
    参数成员只能用 public 或默认(default)这两个访问权修饰
    参数成员只能用基本类型 byte,short,char,int,long,float,double,boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组
    要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法
    注解也可以没有定义成员, 不过这样注解就没啥用了 PS：自定义注解需要使用到元注解</code></pre><p>5、泛型<br>    泛型就是操作类型的 占位符，即：假设占位符为 T，那么此次声明的数据结构操作的数据类型为T类型。</p>
<pre><code>类型通配符
    类型通配符一般是使用 ? 代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是 List&lt;String&gt;，List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt; 的父类。

    类型通配符上限通过形如 List 来定义，如此定义就是通配符泛型值接受 Number 及其下层子类类型。

    类型通配符下限通过形如 List&lt;? super Number&gt; 来定义，表示类型只能接受 Number 及其三层父类类型，如 Objec 类型的实例。</code></pre><p>6、字节与字符<br>    ASCII：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为 8 位二进制数，换算为十进制。最小值 0，最大值 255。<br>    UTF-8：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节<br>    Unicode：一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占 1 个字节的大小，中文句号“。”占 2 个字节的大小。<br>    UTF-16：一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode扩展区的一些汉字存储需要4个字节）<br>    UTF-32：世界上任何字符的存储都需要 4 个字节<br>7、访问修饰符<br>    修饰符      当前类    同 包    子 类    其他包<br>    public        √          √          √          √<br>    protected    √          √          √          ×<br>    default        √          √          ×          ×<br>    private        √          ×          ×          ×</p>
<pre><code>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。
受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。
Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。</code></pre><p>二、面向对象<br>1、Java四个基本特性<br>    抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 <br>    封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。<br>    继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。<br>    多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。</p>
<pre><code>多态的实现方式：
方法重载（overload）：实现的是编译时的多态性（也称为前绑定）。
方法重写（override）：实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西。

要实现多态需要做两件事：
    方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
    对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

项目中对多态的应用
    举一个简单的例子，在物流信息管理系统中，有两种用户：订购客户和卖房客户，两个客户都可以登录系统，他们有相同的方法 Login，但登陆之后他们会进入到不同的页面，也就是在登录的时候会有不同的操作，两种客户都继承父类的 Login 方法，但对于不同的对象，拥有不同的操作。

面相对象开发方式优点（B65）
    较高的开发效率：可以把事物进行抽象，映射为开发的对象。
    保证软件的鲁棒性：高重用性，可以重用已有的而且在相关领域经过长期测试的代码。
    保证软件的高可维护性：代码的可读性非常好，设计模式也使得代码结构清晰，拓展性好。</code></pre><p>2、重载和重写<br>    重载：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。<br>    重写：重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。根据不同的子类对象确定调用的那个方法。<br>3、面向对象开发的六个基本原则<br>    单一职责（Single Responsibility Principle 简称 SRP）：一个类应该仅有一个引起它变化的原因。在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。</p>
<pre><code>里氏替换（Liskov Substitution Principle 简称 LSP）：任何时候子类型能够替换掉它们的父类型。子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。

依赖倒置（Dependence Inversion Principle 简称 DIP）：要依赖于抽象，不要依赖于具体类。要做到依赖倒置，应该做到：①高层模块不应该依赖底层模块，二者都应该依赖于抽象；②抽象不应该依赖于具体实现，具体实现应该依赖于抽象。

接口隔离（Interface Segregation Principle 简称 ISP）：不应该强迫客户依赖于他们不用的方法 。接口要小而专，绝不能大而全。臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。

最少知识原则（Least Knowledge Principle 简称 LKP）：只和你的朋友谈话。迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。

开闭原则（Open Closed Principle 简称 OCP）：软件实体应当对扩展开放，对修改关闭。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱。


项目中用到的原则
单一职责、开放封闭、合成聚合复用(最简单的例子就是String类)、接口隔离</code></pre><p>4、内部类<br>    可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p>
<pre><code>在 Java 中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类
（一）成员内部类

public class OuterClass {
    private String str;

    public void outerDisplay(){
        System.out.println(&quot;outerClass...&quot;);
    }

    public class InnerClass{
        public void innerDisplay(){
            str = &quot;chenssy...&quot;; //使用外围内的属性
            System.out.println(str);
            outerDisplay();  //使用外围内的方法
        }
    }

    // 推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时
    public InnerClass getInnerClass(){
        return new InnerClass();
    }

    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.getInnerClass();
        inner.innerDisplay();
    }
}

在成员内部类中要注意两点：
    成员内部类中不能存在static方法, 但是可以存在static域, 前提是需要使用final关键字进行修饰.
    成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。

（二）局部内部类
有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。

（三）匿名内部类

abstract class Person {
    public abstract void eat();
}

public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}

//在接口上使用匿名内部类
interface Person {
    public void eat();
}

public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}

//Thread类的匿名内部类实现
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i &lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        t.start();
    }
}

//Runnable接口的匿名内部类实现
public class Demo {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            public void run() {
                for (int i = 1; i &lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
    }
}</code></pre><p>5、组合、继承和代理的区别<br>    定义<br>        组合：在新类中 new 另外一个类的对象，以添加该对象的特性。<br>        继承：从基类继承得到子类，获得父类的特性。<br>        代理：在代理类中创建某功能的类，调用类的一些方法以获得该类的部分特性。</p>
<pre><code>使用场合
    组合：各部件之间没什么关系，只需要组合即可。例如组装电脑，需要 new CPU(),new RAM(),new Disk()

    public class Computer {
        public Computer() {
        CPU cpu=new CPU();
        RAM ram=new RAM();
        Disk disk=new Disk();
    }
    }
    class CPU{    }
    class RAM{    }
    class Disk{    }

    继承：子类需要具有父类的功能，各子类之间有所差异。例如 Shape 类作为父类，子类有 Rectangle，CirCle，Triangle……代码不写了，大家都经常用。
    代理：飞机控制类，我不想暴露太多飞机控制的功能，只需部分前进左右转的控制（而不需要暴露发射导弹功能）。通过在代理类中 new 一个飞机控制对象，然后在方法中添加飞机控制类的各个需要暴露的功能。

    public class PlaneDelegation{    
        private PlaneControl planeControl;    //private外部不可访问

        // 飞行员权限代理类，普通飞行员不可以开火
        PlaneDelegation(){
            planeControl = new PlaneControl();
        }
        public void speed(){
            planeControl.speed();
        }
        public void left(){
            planeControl.left();
        }
        public void right(){
            planeControl.right();
        }
    }

    final class PlaneControl {// final表示不可继承，控制器都能继承那还得了
        protected void speed() {}
        protected void fire() {}
        protected void left() {}
        protected void right() {}
    }</code></pre><p>6、构造函数<br>    构造函数中不需要定义返回类型（void 是无需返回值的意思，请注意区分两者），且构造函数的名称与所在的类名完全一致，其余的与函数的特性相同，可以带有参数列表，可以存在函数的重载现象。</p>
<pre><code>构造函数作用
    创建对象。任何一个对象创建时，都需要初始化才能使用，所以任何类想要创建实例对象就必须具有构造函数。
    对象初始化。构造函数可以对对象进行初始化，并且是给与之格式（参数列表）相符合的对象初始化，是具有一定针对性的初始化函数。</code></pre><p>三、关键字<br>1、final和static的区别<br>    -final<br>        （1）数据<br>        声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。<br>        对于基本类型，final使数值不变<br>        对于引用类型，final使引用不变，也不能引用其他对象，但是被引用的对象本身是可以修改的<br>        （2）方法<br>        声明方法不能被子类覆盖，但子类可以使用<br>            private方法隐式地被指定为final，如果在子类中定义地方法和基类中地一个private方法签名相同，此时子类的方法不是覆盖基类的方法，而是在子类中定义了一个新的方法<br>        （3）类<br>        声明类不允许被继承<br>    -static<br>        （1）静态变量<br>        静态变量在内存中只存在一份，只在类初始化时赋值一次。<br>            - 静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；<br>            - 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p>
<pre><code>public class A {
    private int x;        // 实例变量
    public static int y;  // 静态变量
}

不能在成员函数内部定义static变量。

（2）静态方法
静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。
（3）静态语句块
静态语句块在类初始化时运行一次。
（4）静态内部类
内部类的一种，不依赖外部类，且不能访问外部类非静态的变量和方法。
（5）静态导包
import static com.xxx.ClassName.*
在使用静态变量和方法时不再指明ClassName，从而简化代码，但可读性降低
（6）变量赋值顺序
静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行，静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。
运行完上述内容才运行构造函数</code></pre><p>2、break\continue\return<br>    -break<br>    跳出当前循环；但是如果是嵌套循环，则只能跳出当前的这一层循环，只有逐层 break 才能跳出所有循环。<br>    -continue<br>    终止当前循环，但是不跳出循环（在循环中 continue 后面的语句是不会执行了），继续往下根据循环条件执行循环。<br>    -return<br>        return 从当前的方法中退出，返回到该调用的方法的语句处，继续执行。<br>        return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。<br>        return 后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回调用函数处。<br>        特别注意：返回值为 void 的方法，从某个判断中跳出，必须用 return。<br>3、final、finally、finalize<br>    -final（同上）<br>    -finally<br>        在异常处理的时候，提供 finally 块来执行任何的清除操作。如果抛出一个异常，那么相匹配的 catch 字句就会执行，然后控制就会进入 finally 块，前提是有 finally 块。例如：数据库连接关闭操作上</p>
<pre><code>    异常情况说明：
        在执行 try 语句块之前已经返回或抛出异常，所以 try 对应的 finally 语句并没有执行。
        我们在 try 语句块中执行了 System.exit (0) 语句，终止了 Java 虚拟机的运行。那有人说了，在一般的 Java 应用中基本上是不会调用这个 System.exit(0) 方法的
        当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行
        还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。
-finalize
     finalize() 的作用往往被认为是用来做最后的资源回收。 　　基于在自我救赎中的表现来看，此方法有很大的不确定性（不保证方法中的任务执行完）而且运行代价较高。所以用来回收资源也不会有什么好的表现。
     finalize（）没什么用
     至于为什么会存在一个鸡肋的方法：书中说 “它不是 C/C++ 中的析构函数，而是 Java 刚诞生时为了使 C/C++ 程序员更容易接受它所做出的一个妥协”。</code></pre><p>4、assert<br>    断言（assert）作为一种软件调试的方法，提供了一种在代码中进行正确性检查的机制，目前很多开发语言都支持这种机制。</p>
<p>　　在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的状态下，系统将给出警告并且退出。一般来说，assertion 用于保证程序最基本、关键的正确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常是关闭的。下面简单介绍一下 Java 中 assertion 的实现。<br>    在语法上，为了支持 assertion，Java 增加了一个关键字 assert。它包括两种表达式，分别如下：</p>
<p>　　assert &lt;boolean表达式&gt;<br>　　    如果 &lt;boolean表达式&gt; 为 true，则程序继续执行。<br>　　    如果为 false，则程序抛出 AssertionError，并终止执行。<br>　　    assert &lt;boolean表达式&gt; : &lt;错误信息表达式&gt;<br>　　    如果 &lt;boolean表达式&gt; 为 true，则程序继续执行。<br>　　    如果为 false，则程序抛出 java.lang.AssertionError，并输入&lt;错误信息表达式&gt;。<br>5、volatile<br>    volatile 是一个类型修饰符（type specifier），它是被设计用来修饰被不同线程访问和修改的变量。在使用 volatile 修饰成员变量后，所有线程在任何时间所看到变量的值都是相同的。此外，使用 volatile 会组织编译器对代码的优化，因此会降低程序的执行效率。所以，除非迫不得已，否则，能不使用 volatile 就尽量不要使用 volatile。<br>6、instanceof<br>    instanceof 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。<br>    instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。<br>四、基本数据类型与运算<br>1、Java的基本数据类型和引用类型，自动装箱和拆箱<br>    类型    存储<br>整数型<br>    byte    8<br>    short    16<br>    int    32<br>    long    64<br>浮点型<br>    float    32<br>    double    64<br>布尔型<br>    boolean    1<br>字符型<br>    char    16    </p>
<pre><code>自动装箱和拆箱
    基本数据类型和它对应的封装类型之间可以相互转换。自动拆装箱是 jdk5.0 提供的新特特性，它可以自动实现类型的转换
        装箱：从基本数据类型到封装类型叫做装箱
        拆箱：从封装类型到基本数据类型叫拆箱</code></pre><p>2、i++和++i区别<br>i++<br>    i++ 是在程序执行完毕后进行自增，而 ++i 是在程序开始执行前进行自增。<br>i++ 的操作分三步<br>    栈中取出 i<br>    i 自增 1<br>    将 i 存到栈<br>三个阶段：内存到寄存器，寄存器自增，写回内存（这三个阶段中间都可以被中断分离开）<br>所以 i++ 不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致 i 的值不正确自增</p>
<p>++i<br>在多核的机器上，CPU 在读取内存 i 时也会可能发生同时读取到同一值，这就导致两次自增，实际只增加了一次。</p>
<p>i++ 和 ++i 都不是原子操作</p>
<p>原子性：指的是一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程打断。</p>
<p>JMM 三大特性：原子性，可见性，有序性。<br>3、位运算符<br>&amp;：如果相对应位都是 1，则结果为 1，否则为 0<br>|：如果相对应位都是 0，则结果为 0，否则为 1<br>^：如果相对应位值相同，则结果为 0，否则为 1<br>~：按位取反运算符翻转操作数的每一位，即 0 变成 1，1 变成 0<br>&lt;&lt;：（左移一位乘2）按位左移运算符。左操作数按位左移右操作数指定的位数。左移 n 位表示原来的值乘 2^n</p>
<blockquote>
<blockquote>
<p>：（右移一位除2）有符号右移，按位右移运算符。左操作数按位右移右操作数指定的位数</p>
<blockquote>
<p>：无符号右移，按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充<br>4、不用额外变量交换两个整数的值</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>a = a ^ b;
b = a ^ b;
a = a ^ b;</code></pre><p>5、不使用运算符进行a+b操作<br>    a^b; 得到不含进位之和<br>    (a &amp; b)&lt;&lt;1; 进位<br>    只要进位不为零，则迭代；否则返回<br>6、&amp;和&amp;&amp; 、|和||的区别<br>    （1）&amp;&amp; 和 &amp; 都是表示与，区别是 &amp;&amp; 只要第一个条件不满足，后面条件就不再判断。而 &amp; 要对所有的条件都进行判断。<br>    （2）|| 和 | 都是表示 “或”，区别是 || 只要满足第一个条件，后面的条件就不再判断，而 | 要对所有的条件进行判断。<br>五、字符串与数组</p>
<ol>
<li><p>String,StringBuffer,StringBuilder，以及对String不变性的理解<br> String、StringBuffer、StringBuilder</p>
<pre><code>都是 final 类，都不允许被继承
String 长度是不可变的，StringBuffer、StringBuilder 长度是可变的
StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer 在 StringBuilder 的方法之上添加了 synchronized 修饰，保证线程安全
StringBuilder 比 StringBuffer 拥有更好的性能
如果一个 String 类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时 String 的速度比 StringBuffer 和 StringBuilder 的性能好的多</code></pre><p>六、异常处理</p>
</li>
<li><p>常见异常分为那两种(Exception，Error)，常见异常的基类以及常见的异常<br> Throwable 是 Java 语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。</p>
<p> 异常种类</p>
<pre><code>Error：Error 为错误，是程序无法处理的，如 OutOfMemoryError、ThreadDeath 等，出现这种情况你唯一能做的就是听之任之，交由 JVM 来处理，不过 JVM 在大多数情况下会选择终止线程。
Exception：Exception 是程序可以处理的异常。它又分为两种 CheckedException（受捡异常），一种是 UncheckedException（不受检异常）。
受检异常（CheckException）：发生在编译阶段，必须要使用 try…catch（或者throws）否则编译不通过。
非受检异常 （UncheckedException）：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序奔溃并且无法恢复。 （发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的，难以排查，我们一般都需要纵观全局才能够发现这类的异常错误，所以在程序设计中我们需要认真考虑，好好写代码，尽量处理异常，即使产生了异常，也能尽量保证程序朝着有利方向发展。 ）</code></pre><p> 常见异常的基类（Exception）</p>
<pre><code>IOException
RuntimeException</code></pre></li>
</ol>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-排序" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-排序.html">排序</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-排序.html" class="article-date">
  <time datetime="2019-08-01T07:41:26.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>1、选择排序<br>    选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<p>public static void sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length; i++) {<br>        // 寻找[i, n)区间里的最小值的索引<br>        int minIndex = i;<br>        for (int j = i + 1; j &lt; arr.length; j++) {<br>            if(arr[minIndex] &gt; arr[j]){<br>                minIndex = j;<br>            }<br>        }<br>        swap( arr , i , minIndex);<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}</p>
<p>算法分析</p>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>2、插入排序<br>插入排序从左到右进行，每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左部数组依然有序。</p>
<p>第 j 元素是通过不断向左比较并交换来实现插入过程：当第 j 元素小于第 j - 1 元素，就将它们的位置交换，然后令 j 指针向左移动一个位置，不断进行以上操作。<br>public static void sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length - 1; i++) {<br>        for (int j = i + 1; j &gt; 0; j–) {<br>            if (arr[j] &lt; arr[j - 1])<br>                swap(arr, j, j - 1); // 大量的交换会消耗时间<br>            else<br>                break;<br>        }<br>    }<br>}</p>
<p>// 改进版插入排序（减少了数组元素的操作次数）<br>public static void better_sort(int[] arr) {<br>    for (int i = 0; i &lt; arr.length; i++) {<br>        int e = arr[i];<br>        int j = i;<br>        for (; j &gt; 0; j–) {<br>            if (e &lt; arr[j - 1])<br>                arr[j] = arr[j - 1];<br>            else<br>                break;<br>        }<br>        arr[j] = e;<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}<br>算法分析</p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>3、冒泡排序<br>通过从左到右不断交换相邻逆序的相邻元素，在一轮的交换之后，可以让未排序的元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。<br>private static void sort(int[] arr) {<br>    for (int i = arr.length - 1; i &gt; 0; i–) { // 从最后一位开始确定<br>        boolean swapped = false;<br>        for (int j = 0; j &lt; i; j++) {<br>            if(arr[j] &gt; arr[j+1]){<br>                swapped = true;<br>                swap(arr,j,j+1);<br>            }<br>        }<br>        if(!swapped)<br>            return;<br>    }<br>}</p>
<p>private static void swap(int[] arr, int i, int j) {<br>    int t = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = t;<br>}<br>4、希尔排序<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br>// 希尔排序<br>public static void sort(int[] arr) {<br>    int n = arr.length;<br>    for (int h = n / 2; h &gt; 0; h = h / 2) {<br>        // 内部是一个插入排序<br>        for (int i = 0; i &lt; n; i = i + h) {</p>
<pre><code>        int e = arr[i];
        int j = i;
        for (; j &gt; 0; j = j - h) {
            if (e &lt; arr[j - h])
                arr[j] = arr[j - h];
            else
                break;
        }
        arr[j] = e;
    }
}</code></pre><p>}</p>
<p>// 希尔排序2<br>public static void sort2(int[] arr) {<br>    int n = arr.length;<br>    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093…<br>    int h = 1;<br>    while (h &lt; n / 3) h = 3 * h + 1;</p>
<pre><code>System.out.println(h);

while (h &gt;= 1) {
    // h-sort the array
    for (int i = h; i &lt; n; i++) {

        // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序
        int e = arr[i];
        int j = i;
        for (; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)
            arr[j] = arr[j - h];
        arr[j] = e;
    }

    h /= 3;
}</code></pre><p>}<br>算法分析</p>
<p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。</p>
<p>希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。<br>5、归并排序<br>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。<br>private static void sort(int[] arr) {<br>    __MergeSort(arr, 0, arr.length - 1);<br>}</p>
<p>private static void __MergeSort(int[] arr, int l, int r) {<br>    if (l &gt;= r)<br>        return;<br>    int mid = (l + r) / 2;<br>    __MergeSort(arr, l, mid);<br>    __MergeSort(arr, mid + 1, r);<br>    merge(arr, l, mid, r);<br>}</p>
<p>// 将arr[l…mid]和arr[mid+1…r]两部分进行归并<br>private static void merge(int[] arr, int l, int mid, int r) {<br>    int[] aux = Arrays.copyOfRange(arr, l, r + 1);</p>
<pre><code>// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1
int i = l, j = mid + 1;
for (int k = l; k &lt;= r; k++) {
    if (i &gt; mid) {  // 如果左半部分元素已经全部处理完毕
        arr[k] = aux[j - l];
        j++;
    } else if (j &gt; r) {   // 如果右半部分元素已经全部处理完毕
        arr[k] = aux[i - l];
        i++;
    } else if (aux[i - l] &lt; aux[j - l]) {  // 左半部分所指元素 &lt; 右半部分所指元素
        arr[k] = aux[i - l];
        i++;
    } else {  // 左半部分所指元素 &gt;= 右半部分所指元素
        arr[k] = aux[j - l];
        j++;
    }
}</code></pre><p>}</p>
<p>private static void sort(int[] arr) {<br>    int N = arr.length;<br>    int[] aux = new int[N];<br>    for (int sz = 1; sz &lt; N; sz += sz)<br>        for (int i = 0; i + sz &lt; N; i += sz + sz)<br>            merge(arr, i, i + sz - 1, Math.min(i + sz + sz - 1, N - 1));<br>}<br>6、快速排序<br>（1）普通快速排序<br>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>public static void QuickSort(int[] arr,int l,int r){<br>    if(l&gt;=r)<br>        return;<br>    int p = partition(arr,l,r);<br>    QuickSort(arr,l,p-1);<br>    QuickSort(arr,p+1,r);<br>}</p>
<p>// 将数组通过p分割成两部分<br>// 对arr[l…r]部分进行partition操作<br>// 返回p, 使得arr[l…p-1] &lt; arr[p] ; arr[p+1…r] &gt; arr[p]<br>public static int partition(int[] arr, int l, int r) {<br>    swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);  // 加入这一行变成随机快速排序</p>
<pre><code>int v = arr[l];
int j = l;
for(int i = j +1;i&lt;=r;i++){
    if(arr[i] &lt; v){
        j++;
        swap(arr,i,j);
    }
}
swap(arr,l,j);
return j;</code></pre><p>}</p>
<p>public static void swap(int[] arr,int i,int j) {<br>    int temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>}<br>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p>
<p>快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。<br>（2）双路快速排序<br>// 双路快速排序的partition<br>// 返回p, 使得arr[l…p-1] &lt; arr[p] ; arr[p+1…r] &gt; arr[p]<br>private static int partition(int[] arr, int l, int r) {</p>
<pre><code>// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
// swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);

int v = arr[l];

// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v
int i = l + 1, j = r;
while (true) {
    // 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0
    // 思考一下为什么?
    while (i &lt;= r &amp;&amp; arr[i] &lt; v)
        i++;

    // 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0
    // 思考一下为什么?
    while (j &gt;= l + 1 &amp;&amp; arr[j] &gt; v)
        j--;

    // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)
    // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html
    if (i &gt; j)
        break;

    swap(arr, i, j);
    i++;
    j--;
}

swap(arr, l, j);

return j;</code></pre><p>}</p>
<p>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>private static void QuickSort2Ways(int[] arr, int l, int r) {<br>    // 对于小规模数组, 使用插入排序<br>    if (l &gt;= r) return;<br>    int p = partition(arr, l, r);<br>    QuickSort2Ways(arr, l, p - 1);<br>    QuickSort2Ways(arr, p + 1, r);<br>}<br>（3）三路快速排序<br>// 递归使用快速排序,对arr[l…r]的范围进行排序<br>private static void QuickSort3Ways(int[] arr, int l, int r){</p>
<pre><code>// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
swap( arr, l, (int)(Math.random()*(r-l+1)) + l );

int v = arr[l];

int lt = l;     // arr[l+1...lt] &lt; v
int gt = r + 1; // arr[gt...r] &gt; v
int i = l+1;    // arr[lt+1...i) == v
while( i &lt; gt ){
    if( arr[i] &lt; v){
        swap( arr, i, lt+1);
        i ++;
        lt ++;
    }
    else if( arr[i] &gt; v ){
        swap( arr, i, gt-1);
        gt --;
    }
    else{ // arr[i] == v
        i ++;
    }
}
swap( arr, l, lt );

QuickSort3Ways(arr, l, lt-1);
QuickSort3Ways(arr, gt, r);</code></pre><p>}<br>7、堆排序<br>// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序<br>public class HeapSort {</p>
<pre><code>// 对整个arr数组使用HeapSort1排序
// HeapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序
// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)
// 整个堆排序的整体时间复杂度为O(nlogn)
public static void sort1(Comparable[] arr){

    int n = arr.length;
    MaxHeap&lt;Comparable&gt; maxHeap = new MaxHeap&lt;Comparable&gt;(n);
    for( int i = 0 ; i &lt; n ; i ++ )
        maxHeap.insert(arr[i]);

    for( int i = n-1 ; i &gt;= 0 ; i -- )
        arr[i] = maxHeap.extractMax();
}


// 只通过shiftDown操作进行排序
public static void sort2(Comparable[] arr){
    int n = arr.length;

    // 注意，此时我们的堆是从0开始索引的
    // 从(最后一个元素的索引-1)/2开始
    // 最后一个元素的索引 = n-1
    for( int i = (n-1-1)/2 ; i &gt;= 0 ; i -- )
        shiftDown2(arr, n, i);

    for( int i = n-1; i &gt; 0 ; i-- ){ // 这个的目的是让序列从小到大排序
        swap( arr, 0, i);
        shiftDown2(arr, i, 0);
    }
}

// 交换堆中索引为i和j的两个元素
private static void swap(Object[] arr, int i, int j){
    Object t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
}

// 原始的shiftDown过程
private static void shiftDown(Comparable[] arr, int n, int k){
    while( 2*k+1 &lt; n ){
        int j = 2*k+1;
        if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )
            j += 1;

        if( arr[k].compareTo(arr[j]) &gt;= 0 )break;

        swap( arr, k, j);
        k = j;
    }
}

// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,
// 该优化思想和我们之前对插入排序进行优化的思路是一致的
private static void shiftDown2(Comparable[] arr, int n, int k){

    Comparable e = arr[k];
    while( 2*k+1 &lt; n ){
        int j = 2*k+1;
        if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 )
            j += 1;

        if( e.compareTo(arr[j]) &gt;= 0 )
            break;

        arr[k] = arr[j];
        k = j;
    }

    arr[k] = e;
}

// 测试 HeapSort
public static void main(String[] args) {
    Integer[] arr = {10, 91, 8, 7, 6, 5, 4, 3, 2, 1};
    HeapSort.sort2(arr);
    PrintHelper.printArray(arr);
}</code></pre><p>}<br>8、基数排序<br>9、总结<br>         平均时间复杂度        原地排序    额外空间    稳定排序<br>插入排序    O(n^2)               √            O(1)        √<br>归并排序    O(nlogn)           ×            O(n)        √<br>快速排序    O(nlogn)           √            O(logn)        ×<br>堆排序        O(nlogn)           √            O(1)        ×</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-二叉树" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-二叉树.html">二叉树</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-二叉树.html" class="article-date">
  <time datetime="2019-08-01T03:16:34.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>二分查找法<br>// 非递归实现<br>private static int search(int[] data, int l, int r, int target) {<br>    int mid;<br>    while(l &lt; r) {<br>        mid = (l + r) / 2;<br>        if(data[mid] == target) {<br>            return mid;<br>        } else if(data[mid] &lt; target) {<br>            l = mid + 1;<br>        } else {<br>            r = mid;<br>        }<br>    }<br>    return -1;<br>}<br>// 递归实现<br>private static int searchDfs(int[] data, int l, int r, int target) {<br>    if(l &gt;= r) {<br>        return -1;<br>    }<br>    int mid = (l + r) / 2;<br>    if(target == data[mid]) {<br>        return mid;<br>    } else if(target &gt; data[mid]) {<br>        return searchDfs(data, mid + 1, r, target);<br>    } else {<br>        return searchDfs(data, l, mid, target);<br>    }<br>}</p>
<p>#二叉树遍历<br>/**</p>
<ul>
<li>前序遍历 非递归实现</li>
<li>Definition for a binary tree node.</li>
<li>struct TreeNode {</li>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
<li>};</li>
<li>/<br>class Solution {<br>public:<br>  vector<int> preorderTraversal(TreeNode* root) {<pre><code>vector&lt;int&gt; ans;
TreeNode* node = root;
stack&lt;TreeNode*&gt; s;
map&lt;TreeNode*, bool&gt; M;
if(node != NULL) {
    s.push(node);
    while (!s.empty()) {
        node = s.top();
        if (!M[node]) {
            ans.push_back(node-&gt;val);
            M[node] = true;
        }
        if (node-&gt;left != NULL) {
            s.push(node-&gt;left);
            node-&gt;left = NULL;
        } else if (node-&gt;right != NULL) {
            s.push(node-&gt;right);
            node-&gt;right = NULL;
        } else {
            s.pop();
        }
    }
}
return ans;</code></pre>  }<br>};</int></li>
</ul>
<p>/**</p>
<ul>
<li><p>中序遍历</p>
</li>
<li><p>Definition for a binary tree node.</p>
</li>
<li><p>struct TreeNode {</p>
</li>
<li><p>int val;</p>
</li>
<li><p>TreeNode *left;</p>
</li>
<li><p>TreeNode *right;</p>
</li>
<li><p>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</p>
</li>
<li><p>};</p>
</li>
<li><p>/<br>class Solution {<br>public:<br>  vector<int> inorderTraversal(TreeNode* root) {</int></p>
<pre><code>vector&lt;int&gt; ans;
if(root != NULL) {
    traversal(root, ans);
}
return ans;</code></pre><p>  }</p>
<p>  void traversal(TreeNode* node, vector<int> &amp;ans) {</int></p>
<pre><code>if(node-&gt;left != NULL) {
    traversal(node-&gt;left, ans);
}
ans.push_back(node-&gt;val);
if(node-&gt;right != NULL) {
    traversal(node-&gt;right, ans);
}</code></pre><p>  }<br>};</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>后序遍历</p>
</li>
<li><p>Definition for a binary tree node.</p>
</li>
<li><p>struct TreeNode {</p>
</li>
<li><p>int val;</p>
</li>
<li><p>TreeNode *left;</p>
</li>
<li><p>TreeNode *right;</p>
</li>
<li><p>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</p>
</li>
<li><p>};</p>
</li>
<li><p>/<br>class Solution {<br>public:<br>  vector<int> postorderTraversal(TreeNode* root) {</int></p>
<pre><code>vector&lt;int&gt; ans;
if(root != NULL) {
    traversal(root, ans);
}
return ans;</code></pre><p>  }</p>
<p>  void traversal(TreeNode* node, vector<int> &amp;ans) {</int></p>
<pre><code>if(node-&gt;left != NULL) {
    traversal(node-&gt;left, ans);
}
if(node-&gt;right != NULL) {
    traversal(node-&gt;right, ans);
}
ans.push_back(node-&gt;val);</code></pre><p>  }<br>};</p>
</li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-红黑树" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/技术/2019-08-01-红黑树.html">红黑树</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-01-红黑树.html" class="article-date">
  <time datetime="2019-08-01T01:01:08.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>treeMap左旋<br>//Rotate Left<br>private void rotateLeft(Entry&lt;K,V&gt; p) {<br>    if (p != null) {<br>        Entry&lt;K,V&gt; r = p.right;<br>        p.right = r.left;<br>        if (r.left != null)<br>            r.left.parent = p;<br>        r.parent = p.parent;<br>        if (p.parent == null)<br>            root = r;<br>        else if (p.parent.left == p)<br>            p.parent.left = r;<br>        else<br>            p.parent.right = r;<br>        r.left = p;<br>        p.parent = r;<br>    }<br>}</p>
<p>treeMap右旋<br>//Rotate Right<br>private void rotateRight(Entry&lt;K,V&gt; p) {<br>    if (p != null) {<br>        Entry&lt;K,V&gt; l = p.left;<br>        p.left = l.right;<br>        if (l.right != null) l.right.parent = p;<br>        l.parent = p.parent;<br>        if (p.parent == null)<br>            root = l;<br>        else if (p.parent.right == p)<br>            p.parent.right = l;<br>        else p.parent.left = l;<br>        l.right = p;<br>        p.parent = l;<br>    }<br>}</p>
<p>treeMap寻找节点后继<br>// 寻找节点后继函数successor()<br>static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {<br>    if (t == null)<br>        return null;<br>    else if (t.right != null) {// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素<br>        Entry&lt;K,V&gt; p = t.right;<br>        while (p.left != null)<br>            p = p.left;<br>        return p;<br>    } else {// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先<br>        Entry&lt;K,V&gt; p = t.parent;<br>        Entry&lt;K,V&gt; ch = t;<br>        while (p != null &amp;&amp; ch == p.right) {<br>            ch = p;<br>            p = p.parent;<br>        }<br>        return p;<br>    }<br>}</p>
<p>get()方法<br>get(Object key)方法根据指定的key值返回对应的value，该方法调用<br>了getEntry(Object key)得到相应的entry，然后返回entry.value。<br>因此getEntry()是算法的核心。算法思想是根据key的自然顺序<br>（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。<br>//getEntry()方法<br>final Entry&lt;K,V&gt; getEntry(Object key) {<br>    ……<br>    if (key == null)//不允许key值为null<br>        throw new NullPointerException();<br>    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序<br>    Entry&lt;K,V&gt; p = root;<br>    while (p != null) {<br>        int cmp = k.compareTo(p.key);<br>        if (cmp &lt; 0)//向左找<br>            p = p.left;<br>        else if (cmp &gt; 0)//向右找<br>            p = p.right;<br>        else<br>            return p;<br>    }<br>    return null;<br>}</p>
<p>put()方法<br>put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，<br>看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则<br>会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改<br>变某些节点的颜色）。<br>public V put(K key, V value) {<br>    ……<br>    int cmp;<br>    Entry&lt;K,V&gt; parent;<br>    if (key == null)<br>        throw new NullPointerException();<br>    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序<br>    do {<br>        parent = t;<br>        cmp = k.compareTo(t.key);<br>        if (cmp &lt; 0) t = t.left;//向左找<br>        else if (cmp &gt; 0) t = t.right;//向右找<br>        else return t.setValue(value);<br>    } while (t != null);<br>    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry<br>    if (cmp &lt; 0) parent.left = e;<br>    else parent.right = e;<br>    fixAfterInsertion(e);//调整<br>    size++;<br>    return null;<br>}</p>
<p>//红黑树调整函数fixAfterInsertion()<br>private void fixAfterInsertion(Entry&lt;K,V&gt; x) {<br>    x.color = RED;<br>    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {<br>        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {<br>            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));<br>            if (colorOf(y) == RED) {<br>                setColor(parentOf(x), BLACK);              // 情况1<br>                setColor(y, BLACK);                        // 情况1<br>                setColor(parentOf(parentOf(x)), RED);      // 情况1<br>                x = parentOf(parentOf(x));                 // 情况1<br>            } else {<br>                if (x == rightOf(parentOf(x))) {<br>                    x = parentOf(x);                       // 情况2<br>                    rotateLeft(x);                         // 情况2<br>                }<br>                setColor(parentOf(x), BLACK);              // 情况3<br>                setColor(parentOf(parentOf(x)), RED);      // 情况3<br>                rotateRight(parentOf(parentOf(x)));        // 情况3<br>            }<br>        } else {<br>            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));<br>            if (colorOf(y) == RED) {<br>                setColor(parentOf(x), BLACK);              // 情况4<br>                setColor(y, BLACK);                        // 情况4<br>                setColor(parentOf(parentOf(x)), RED);      // 情况4<br>                x = parentOf(parentOf(x));                 // 情况4<br>            } else {<br>                if (x == leftOf(parentOf(x))) {<br>                    x = parentOf(x);                       // 情况5<br>                    rotateRight(x);                        // 情况5<br>                }<br>                setColor(parentOf(x), BLACK);              // 情况6<br>                setColor(parentOf(parentOf(x)), RED);      // 情况6<br>                rotateLeft(parentOf(parentOf(x)));         // 情况6<br>            }<br>        }<br>    }<br>    root.color = BLACK;<br>}</p>
<p>remove()函数<br>remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p>
<p>getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。</p>
<p>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p>
<p>删除点p的左右子树都为空，或者只有一棵子树非空。<br>删除点p的左右子树都非空。<br>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）。</p>
<p>基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下：<br>// 红黑树entry删除函数deleteEntry()<br>private void deleteEntry(Entry&lt;K,V&gt; p) {<br>    modCount++;<br>    size–;<br>    if (p.left != null &amp;&amp; p.right != null) {// 2. 删除点p的左右子树都非空。<br>        Entry&lt;K,V&gt; s = successor(p);// 后继<br>        p.key = s.key;<br>        p.value = s.value;<br>        p = s;<br>    }<br>    Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);<br>    if (replacement != null) {// 1. 删除点p只有一棵子树非空。<br>        replacement.parent = p.parent;<br>        if (p.parent == null)<br>            root = replacement;<br>        else if (p == p.parent.left)<br>            p.parent.left  = replacement;<br>        else<br>            p.parent.right = replacement;<br>        p.left = p.right = p.parent = null;<br>        if (p.color == BLACK)<br>            fixAfterDeletion(replacement);// 调整<br>    } else if (p.parent == null) {<br>        root = null;<br>    } else { // 1. 删除点p的左右子树都为空<br>        if (p.color == BLACK)<br>            fixAfterDeletion(p);// 调整<br>        if (p.parent != null) {<br>            if (p == p.parent.left)<br>                p.parent.left = null;<br>            else if (p == p.parent.right)<br>                p.parent.right = null;<br>            p.parent = null;<br>        }<br>    }<br>}</p>
<p>private void fixAfterDeletion(Entry&lt;K,V&gt; x) {<br>    while (x != root &amp;&amp; colorOf(x) == BLACK) {<br>        if (x == leftOf(parentOf(x))) {<br>            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));<br>            if (colorOf(sib) == RED) {<br>                setColor(sib, BLACK);                   // 情况1<br>                setColor(parentOf(x), RED);             // 情况1<br>                rotateLeft(parentOf(x));                // 情况1<br>                sib = rightOf(parentOf(x));             // 情况1<br>            }<br>            if (colorOf(leftOf(sib))  == BLACK &amp;&amp;<br>                colorOf(rightOf(sib)) == BLACK) {<br>                setColor(sib, RED);                     // 情况2<br>                x = parentOf(x);                        // 情况2<br>            } else {<br>                if (colorOf(rightOf(sib)) == BLACK) {<br>                    setColor(leftOf(sib), BLACK);       // 情况3<br>                    setColor(sib, RED);                 // 情况3<br>                    rotateRight(sib);                   // 情况3<br>                    sib = rightOf(parentOf(x));         // 情况3<br>                }<br>                setColor(sib, colorOf(parentOf(x)));    // 情况4<br>                setColor(parentOf(x), BLACK);           // 情况4<br>                setColor(rightOf(sib), BLACK);          // 情况4<br>                rotateLeft(parentOf(x));                // 情况4<br>                x = root;                               // 情况4<br>            }<br>        } else { // 跟前四种情况对称<br>            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));<br>            if (colorOf(sib) == RED) {<br>                setColor(sib, BLACK);                   // 情况5<br>                setColor(parentOf(x), RED);             // 情况5<br>                rotateRight(parentOf(x));               // 情况5<br>                sib = leftOf(parentOf(x));              // 情况5<br>            }<br>            if (colorOf(rightOf(sib)) == BLACK &amp;&amp;<br>                colorOf(leftOf(sib)) == BLACK) {<br>                setColor(sib, RED);                     // 情况6<br>                x = parentOf(x);                        // 情况6<br>            } else {<br>                if (colorOf(leftOf(sib)) == BLACK) {<br>                    setColor(rightOf(sib), BLACK);      // 情况7<br>                    setColor(sib, RED);                 // 情况7<br>                    rotateLeft(sib);                    // 情况7<br>                    sib = leftOf(parentOf(x));          // 情况7<br>                }<br>                setColor(sib, colorOf(parentOf(x)));    // 情况8<br>                setColor(parentOf(x), BLACK);           // 情况8<br>                setColor(leftOf(sib), BLACK);           // 情况8<br>                rotateRight(parentOf(x));               // 情况8<br>                x = root;                               // 情况8<br>            }<br>        }<br>    }<br>    setColor(x, BLACK);<br>}</p>
<p>TreeSet<br>// TreeSet是对TreeMap的简单包装<br>public class TreeSet<e> extends AbstractSet<e><br>    implements NavigableSet<e>, Cloneable, java.io.Serializable<br>{<br>    ……<br>    private transient NavigableMap&lt;E,Object&gt; m;<br>    // Dummy value to associate with an Object in the backing Map<br>    private static final Object PRESENT = new Object();<br>    public TreeSet() {<br>        this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap<br>    }<br>    ……<br>    public boolean add(E e) {<br>        return m.put(e, PRESENT)==null;<br>    }<br>    ……<br>}</e></e></e></p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-test" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/uncategorized/2019-07-31-test.html">test</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/uncategorized/2019-07-31-test.html" class="article-date">
  <time datetime="2019-07-31T13:37:35.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/历史/">历史</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>test</p>

      
    </div>
    
  </div>
  
  
</article>

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>


</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.webp" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        天佑昨日
      
    </h3>
    <p class="avatar-slogan">
      明日不可求 幸得昨日来
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/技术/2019-08-08-Java-Web.html">Java Web</a>
          </li>
        
          <li>
            <a href="/posts/uncategorized/2019-08-08-Java虚拟机.html">Java虚拟机</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-07-Java-IOO.html">Java IO</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-06-Java并发编程.html">Java并发编程</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-06-Java集合框架.html">Java集合框架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://dretrtg.github.io/" title target='_blank'
        >dretrtg</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 dretrtg &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>
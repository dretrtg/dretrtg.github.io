<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Java集合框架 | dretrtg的站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="description" content="一、概述    主要有三大类：Collection（接口）、Map(接口)、集合工具类 Collection     ArrayList:线程不同步。默认初始容量为10，当数组大小不足时容量扩大为1.5倍，如果需要多线程并发访问，用户可以手动同步，也可以用vector代替。     LinkedList:线程不同步，双向链接实现。当需要使用栈或者队列时，可以考虑使用LinkedList，关于栈或队">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合框架">
<meta property="og:url" content="http://yoursite.com/posts/技术/2019-08-06-Java集合框架.html">
<meta property="og:site_name" content="dretrtg的站">
<meta property="og:description" content="一、概述    主要有三大类：Collection（接口）、Map(接口)、集合工具类 Collection     ArrayList:线程不同步。默认初始容量为10，当数组大小不足时容量扩大为1.5倍，如果需要多线程并发访问，用户可以手动同步，也可以用vector代替。     LinkedList:线程不同步，双向链接实现。当需要使用栈或者队列时，可以考虑使用LinkedList，关于栈或队">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-06T02:27:47.460Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java集合框架">
<meta name="twitter:description" content="一、概述    主要有三大类：Collection（接口）、Map(接口)、集合工具类 Collection     ArrayList:线程不同步。默认初始容量为10，当数组大小不足时容量扩大为1.5倍，如果需要多线程并发访问，用户可以手动同步，也可以用vector代替。     LinkedList:线程不同步，双向链接实现。当需要使用栈或者队列时，可以考虑使用LinkedList，关于栈或队">
  
    <link rel="alternate" href="/atom.xml" title="dretrtg的站" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.webp">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
  <script>
  let antiquityStorage = window.sessionStorage.getItem('antiquitySessionStorage');
  if (antiquityStorage == '' || antiquityStorage == null) {
    var antiquityLoader = '<div id="loaderbox"><div class="loader"><div class="load-roll"><div class="load-top"></div><div class="load-right"></div><div class="load-bottom"></div></div></div></div>';
    document.write(antiquityLoader);
    document.body.style.overflow = 'hidden'
  }
  </script>
</head>
</html>
<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main"><article id="post-Java集合框架" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      Java集合框架
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/posts/技术/2019-08-06-Java集合框架.html" class="article-date">
  <time datetime="2019-08-06T00:24:26.000Z" itemprop="datePublished">2019-08-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

  </div>
  
    <span id="busuanzi_container_page_pv">
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
    </span>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>一、概述<br>    主要有三大类：Collection（接口）、Map(接口)、集合工具类</p>
<pre><code>Collection
    ArrayList:线程不同步。默认初始容量为10，当数组大小不足时容量扩大为1.5倍，如果需要多线程并发访问，用户可以手动同步，也可以用vector代替。
    LinkedList:线程不同步，双向链接实现。当需要使用栈或者队列时，可以考虑使用LinkedList，关于栈或队列，现在的首选时ArrayDeque，当作栈或队列使用时比LinkedList性能更好。
    Vector：线程同步。默认初始容量为10，当数组大小不足时容量扩大为2倍。它的同步是通过Iterator方法加synchronized实现的。
    TreeSet：线程不同步，默认元素自然顺序排列，可以通过Comparator改变排序。
    HashSet：线程不同步，提供的方法基本都是调用HashMap方法，两者本质一样。
    Set：Set是一种不包含重复元素的Collection，Set最多只有一个null元素。

Map
    TreeMap：线程不同步，基于红黑树实现，能把它保存的记录根据键排序，默认是按键值的升序排序，其方法时间复杂度都为log（n）。
    HashTable：线程安全。不能存储NULL的key和value。
    HashMap：线程不同步。根据key的hashcode进行存储，内部使用静态内部类Node数组进行存储，默认初始大小为16，每次扩大一倍，当单个桶中元素个数大于等于8时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现，以此防止hshCode攻击。
    LinkedHashMap：保存了记录的插入顺序。

工具类
    Collections、Arrays
    Comparable、Comparator</code></pre><p>二、深入源码分析<br>ArrayList<br>    1、概览<br>        实现了 RandomAccess 接口，因此支持随机访问，这是理所当然的，因为 ArrayList 是基于数组实现的。</p>
<pre><code>    public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable

    数组默认大小为10

    private static final int DEFAULT_CAPACITY = 10;

2、序列化
    ArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 重写了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。

    transient Object[] elementData; // non-private to simplify nested class access

3、扩容
    扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。

4、删除元素
    需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上。</code></pre><p>Vector<br>    1、同步<br>        实现与ArrayList类似，但是使用了synchronized进行同步<br>    2、ArrayList与Vector<br>        vector是同步的，开销比ArrayList要大，访问速度慢。最好使用ArrayList，同步可以手动控制。<br>        Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。</p>
<p>LinkedList<br>    1、概述<br>        LinkedList底层是基于双向链表实现的<br>    2、add()<br>        末尾插入元素是常数时间；在指定位置插入元素需要先通过线性查找找到具体位置，然后修改相关引用完成插入<br>    3、remove()<br>        先找到要删除元素的引用；修改引用完成删除（通过unlink（Node<e>x）方法完成）。<br>    4、get()<br>        使用二分查找看index离size中间距离判断是正序查还是倒序查。<br>    5、总结<br>        LinkedList插入删除都是移动指针效率很高。<br>        查找需要遍历查询，效率很低。<br>    6、ArrayList与LinkedList<br>        ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；<br>        ArrayList 支持随机访问，LinkedList 不支持；<br>        LinkedList 在任意位置添加删除元素更快。</e></p>
<p>HashMap<br>    1、存储结构<br>        对于 JDK1.8 之后的 HashMap 底层在解决哈希冲突的时候，就不单单是使用数组加上单链表的组合了，因为当处理如果 hash 值冲突较多的情况下，链表的长度就会越来越长，此时通过单链表来寻找对应 Key 对应的 Value 的时候就会使得时间复杂度达到 O(n)，因此在 JDK1.8 之后，在链表新增节点导致链表长度超过 TREEIFY_THRESHOLD = 8 的时候，就会在添加元素的同时将原来的单链表转化为红黑树。</p>
<pre><code>原因：</code></pre><p>　　        红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。<br>        还有选择6和8的原因是：<br>　　        中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。<br>            理想情况下，在随机哈希代码下，桶中的节点频率遵循泊松分布，桶的长度超过8的概率很小，因此依据概率统计选择8作为阈值。</p>
<pre><code>    HashMap是数组+链表+红黑树实现的

    hashMap存储的是键值对Node
2、确定哈希桶数组索引位置
    先确定一个键值对所在的桶下标
    （1）计算key的hash值
    （2）取模
3、put()
    ①.判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；

    ②.根据键值 key 计算 hash 值得到插入的数组索引i，如果 table[i]==null，直接新建节点添加，转向 ⑥，如果table[i] 不为空，转向 ③；

    ③.判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 ④，这里的相同指的是 hashCode 以及 equals；

    ④.判断table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 ⑤；

    ⑤.遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；

    ⑥.插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。

    public V put(K key, V value) {
    // 对key的hashCode()做hash
        return putVal(hash(key), key, value, false, true);
    }

    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
           boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        // 步骤①：tab为空则创建
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
            // 步骤②：计算index，并对null做处理 
        if ((p = tab[i = (n - 1) &amp; hash]) == null) 
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            // 步骤③：节点key存在，直接覆盖value
            if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            // 步骤④：判断该链为红黑树
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            // 步骤⑤：该链为链表
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key,value,null);
                        //链表长度大于8转换为红黑树进行处理
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  
                            treeifyBin(tab, hash);
                            break;
                        }
                        // key已经存在直接覆盖value
                        if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) 
                            break;
                            p = e;
                        }
                }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        // 步骤⑥：超过最大容量 就扩容
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

4、线程安全性
    在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。
5、HashMap与HashTable
    HashTable 使用 synchronized 来进行同步。
    HashMap 可以插入键为 null 的 Entry。
    HashMap 的迭代器是 fail-fast 迭代器。
    HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
6、小结
    扩容是一个特别耗性能的操作，所以当程序员在使用 HashMap 的时候，估算 map 的大小，初始化的时候给一个大致的数值，避免 map 进行频繁的扩容。
    负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。
    HashMap 是线程不安全的，不要在并发的环境中同时操作 HashMap，建议使用 ConcurrentHashMap。
    JDK1.8 引入红黑树大程度优化了 HashMap 的性能。</code></pre><p>ConcurrentHashMap<br>    ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。<br>    默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<p>三、容器中的设计模式<br>迭代器模式<br>    Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。<br>适配器模式<br>    java.util.Arrays.asList() 可以把数组类型转换为 List 类型。<br>四、面试指南<br>    1. ArrayList和LinkedList区别<br>        ArrayList 和 LinkedList 可想从名字分析，它们一个是 Array (动态数组) 的数据结构，一个是 Link (链表) 的数据结构，此外，它们两个都是对 List 接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列；</p>
<pre><code>    当随机访问 List 时（get和set操作），ArrayList 比 LinkedList的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找；

    当对数据进行增加和删除的操作时（add 和 remove 操作），LinkedList 比 ArrayList 的效率更高，因为 ArrayList 是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动；

    从利用效率来看，ArrayList 自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用；

    ArrayList 主要空间开销在于需要在 List 列表预留一定空间；而 LinkList 主要控件开销在于需要存储结点信息以及结点指针信息。

    ArrayList、LinkedList 和 Vector如何选择？

        当对数据的主要操作为索引或只在集合的末端增加、删除元素时，使用 ArrayList 或 Vector 效率比较高；
        当对数据的操作主要为制定位置的插入或删除操作时，使用 LinkedList 效率比较高；
        当在多线程中使用容器时（即多个线程会同时访问该容器），选用 Vector 较为安全；

2. HashMap和HashTable区别，HashMap的key类型
Hash Map和HashTable的区别

    Hashtable 的方法是同步的，HashMap 非同步，所以在多线程场合要手动同步

    Hashtable 不允许 null 值 (key 和 value 都不可以)，HashMap 允许 null 值( key 和 value 都可以)。

    两者的遍历方式大同小异，Hashtable 仅仅比 HashMap 多一个 elements 方法。

    Hashtable 和 HashMap 都能通过 values() 方法返回一个 Collection ，然后进行遍历处理。

    两者也都可以通过 entrySet() 方法返回一个 Set ， 然后进行遍历处理。

    HashTable 使用 Enumeration，HashMap 使用 Iterator。

    哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。

    Hashtable 中 hash 数组默认大小是11，增加的方式是 old*2+1。HashMap 中 hash 数组的默认大小是16，而且一定是 2 的指数。

    HashTable 基于 Dictionary 类，而 HashMap 基于 AbstractMap 类

HashMap中的key可以是任何对象或数据类型吗
    可以为null，但不能是可变对象，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。
    如果可变对象在 HashMap 中被用作键，那就要小心在改变对象状态的时候，不要改变它的哈希值了。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。

    HashTable是线程安全的么
        HashTable 是线程安全的，其实现是在对应的方法上添加了 synchronized 关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以现在如果为了保证线程安全的话，使用 CurrentHashMap。

3. HashMap和ConcurrentHashMap
    HashMap和Concurrent HashMap区别？
        HashMa p是非线程安全的，CurrentHashMap 是线程安全的。
        ConcurrentHashMap 将整个 Hash 桶进行了分段 segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁。
        ConcurrentHashMap 让锁的粒度更精细一些，并发性能更好。
    ConcurrentHashMap 线程安全吗， ConcurrentHashMap如何保证 线程安全？
        HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable 的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是 ConcurrentHashMap 所使用的分段锁，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。
        get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空的才会加锁重读。get 方法里将要使用的共享变量都定义成 volatile，如用于统计当前 Segement 大小的 count 字段和用于存储值的 HashEntry 的 value。定义成 volatile 的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value，所以可以不用加锁。
        put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。
            插入操作需要经历两个步骤：（1）判断是否需要对 Segment 里的 HashEntry 数组进行扩容；（2）定位添加元素的位置然后放在HashEntry数组里。
4、Hash冲突解决办法
    链地址法
    开放地址法（向后一位）
        线性探测
        平方探测
        二次哈希
    再哈希法
5、hashmap 始终将自己的桶保持在2n，这是为什么？
    计算机里位运算是基本运算，位运算效率远高于取余运算。在hashmap里获取要存放的数组下标需要进行取模，为提高效率采用位运算
        举个例子：2n 转换成二进制就是 1+n 个 0，减 1 之后就是 0+n个1，如16 -&gt; 10000，15 -&gt; 01111
        那么根据 &amp; 位运算的规则，都为 1 (真)时，才为 1，那 0≤运算后的结果≤15，假设 h &lt;= 15，那么运算后的结果就是 h 本身，h &gt;15，运算后的结果就是最后四位二进制做 &amp; 运算后的值，最终，就是 % 运算后的余数。
        当容量一定是 2n 时，h &amp; (length - 1) == h % length</code></pre>
      
    </div>
    
      <footer class="article-footer">
        完
      </footer>
    
  </div>
  
    
<nav id="article-nav">
  <div class="article-nav-block">
    
      <a href="/posts/技术/2019-08-06-Java并发编程.html" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption"></strong>
        <div class="article-nav-title">
          
            Java并发编程
          
        </div>
      </a>
    
  </div>
  <div class="article-nav-block">
    
      <a href="/posts/技术/2019-08-02-Java基础.html" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">Java基础</div>
        <strong class="article-nav-caption"></strong>
      </a>
    
  </div>
</nav>

    
<div id="gitmentContainer"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  owner: '',
  repo: '',
  oauth: {
    client_id: '',
    client_secret: '',
  },
})
gitment.render('gitmentContainer')
</script>

  
  
</article>
</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.webp" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        天佑昨日
      
    </h3>
    <p class="avatar-slogan">
      明日不可求 幸得昨日来
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/技术/2019-08-07-Java-IOO.html">Java IO</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-06-Java并发编程.html">Java并发编程</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-06-Java集合框架.html">Java集合框架</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-02-Java基础.html">Java基础</a>
          </li>
        
          <li>
            <a href="/posts/技术/2019-08-01-排序.html">排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://dretrtg.github.io/" title target='_blank'
        >dretrtg</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2019 dretrtg &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>